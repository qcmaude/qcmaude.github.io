{"ast":null,"code":"/** @packageDocumentation @publicapi @module state */\nimport { inArray, isString, prop } from '../common';\nimport { StateObject } from './stateObject';\n/** @internalapi */\n\nvar StateQueueManager =\n/** @class */\nfunction () {\n  function StateQueueManager(router, states, builder, listeners) {\n    this.router = router;\n    this.states = states;\n    this.builder = builder;\n    this.listeners = listeners;\n    this.queue = [];\n  }\n  /** @internalapi */\n\n\n  StateQueueManager.prototype.dispose = function () {\n    this.queue = [];\n  };\n\n  StateQueueManager.prototype.register = function (stateDecl) {\n    var queue = this.queue;\n    var state = StateObject.create(stateDecl);\n    var name = state.name;\n    if (!isString(name)) throw new Error('State must have a valid name');\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name)) throw new Error(\"State '\" + name + \"' is already defined\");\n    queue.push(state);\n    this.flush();\n    return state;\n  };\n\n  StateQueueManager.prototype.flush = function () {\n    var _this = this;\n\n    var _a = this,\n        queue = _a.queue,\n        states = _a.states,\n        builder = _a.builder;\n\n    var registered = [],\n        // states that got registered\n    orphans = [],\n        // states that don't yet have a parent registered\n    previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\n    var getState = function (name) {\n      return _this.states.hasOwnProperty(name) && _this.states[name];\n    };\n\n    var notifyListeners = function () {\n      if (registered.length) {\n        _this.listeners.forEach(function (listener) {\n          return listener('registered', registered.map(function (s) {\n            return s.self;\n          }));\n        });\n      }\n    };\n\n    while (queue.length > 0) {\n      var state = queue.shift();\n      var name_1 = state.name;\n      var result = builder.build(state);\n      var orphanIdx = orphans.indexOf(state);\n\n      if (result) {\n        var existingState = getState(name_1);\n\n        if (existingState && existingState.name === name_1) {\n          throw new Error(\"State '\" + name_1 + \"' is already defined\");\n        }\n\n        var existingFutureState = getState(name_1 + '.**');\n\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.router.stateRegistry.deregister(existingFutureState);\n        }\n\n        states[name_1] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      var prev = previousQueueLength[name_1];\n      previousQueueLength[name_1] = queue.length;\n\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        notifyListeners();\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    notifyListeners();\n    return states;\n  };\n\n  StateQueueManager.prototype.attachRoute = function (state) {\n    if (state.abstract || !state.url) return;\n    var rulesApi = this.router.urlService.rules;\n    rulesApi.rule(rulesApi.urlRuleFactory.create(state));\n  };\n\n  return StateQueueManager;\n}();\n\nexport { StateQueueManager };","map":{"version":3,"sources":["@uirouter/core/state/stateQueueManager.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,OAAT,EAAkB,QAAlB,EAA4B,IAA5B,QAAwC,WAAxC;AAEA,SAAS,WAAT,QAA4B,eAA5B;AAMA;;AACA,IAAA,iBAAA;AAAA;AAAA,YAAA;AAGE,WAAA,iBAAA,CACU,MADV,EAES,MAFT,EAGS,OAHT,EAIS,SAJT,EAI2C;AAHjC,SAAA,MAAA,GAAA,MAAA;AACD,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,SAAA,GAAA,SAAA;AANT,SAAA,KAAA,GAAuB,EAAvB;AAOI;AAEJ;;;AACA,EAAA,iBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,SAAK,KAAL,GAAa,EAAb;AACD,GAFD;;AAIA,EAAA,iBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,SAAT,EAAqC;AACnC,QAAM,KAAK,GAAG,KAAK,KAAnB;AACA,QAAM,KAAK,GAAG,WAAW,CAAC,MAAZ,CAAmB,SAAnB,CAAd;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;AAEA,QAAI,CAAC,QAAQ,CAAC,IAAD,CAAb,EAAqB,MAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACrB,QAAI,KAAK,MAAL,CAAY,cAAZ,CAA2B,IAA3B,KAAoC,OAAO,CAAC,KAAK,CAAC,GAAN,CAAU,IAAI,CAAC,MAAD,CAAd,CAAD,EAA0B,IAA1B,CAA/C,EACE,MAAM,IAAI,KAAJ,CAAU,YAAU,IAAV,GAAc,sBAAxB,CAAN;AAEF,IAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACA,SAAK,KAAL;AAEA,WAAO,KAAP;AACD,GAbD;;AAeA,EAAA,iBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACQ,QAAA,EAAA,GAAA,IAAA;AAAA,QAAE,KAAA,GAAA,EAAA,CAAA,KAAF;AAAA,QAAS,MAAA,GAAA,EAAA,CAAA,MAAT;AAAA,QAAiB,OAAA,GAAA,EAAA,CAAA,OAAjB;;AACN,QAAM,UAAU,GAAkB,EAAlC;AAAA,QAAsC;AACpC,IAAA,OAAO,GAAkB,EAD3B;AAAA,QAC+B;AAC7B,IAAA,mBAAmB,GAAG,EAFxB,CAFF,CAI8B;;AAC5B,QAAM,QAAQ,GAAG,UAAA,IAAA,EAAI;AAAI,aAAA,KAAI,CAAC,MAAL,CAAY,cAAZ,CAA2B,IAA3B,KAAoC,KAAI,CAAC,MAAL,CAApC,IAAoC,CAApC;AAAqD,KAA9E;;AACA,QAAM,eAAe,GAAG,YAAA;AACtB,UAAI,UAAU,CAAC,MAAf,EAAuB;AACrB,QAAA,KAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,UAAA,QAAA,EAAQ;AAAI,iBAAA,QAAQ,CAAC,YAAD,EAAe,UAAU,CAAC,GAAX,CAAe,UAAA,CAAA,EAAC;AAAI,mBAAA,CAAC,CAAD,IAAA;AAA3C,WAAuB,CAAf,CAAR;AAAmD,SAAtF;AACD;AACF,KAJD;;AAMA,WAAO,KAAK,CAAC,MAAN,GAAe,CAAtB,EAAyB;AACvB,UAAM,KAAK,GAAgB,KAAK,CAAC,KAAN,EAA3B;AACA,UAAM,MAAI,GAAG,KAAK,CAAC,IAAnB;AACA,UAAM,MAAM,GAAgB,OAAO,CAAC,KAAR,CAAc,KAAd,CAA5B;AACA,UAAM,SAAS,GAAW,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAA1B;;AAEA,UAAI,MAAJ,EAAY;AACV,YAAM,aAAa,GAAG,QAAQ,CAAC,MAAD,CAA9B;;AACA,YAAI,aAAa,IAAI,aAAa,CAAC,IAAd,KAAuB,MAA5C,EAAkD;AAChD,gBAAM,IAAI,KAAJ,CAAU,YAAU,MAAV,GAAc,sBAAxB,CAAN;AACD;;AAED,YAAM,mBAAmB,GAAG,QAAQ,CAAC,MAAI,GAAG,KAAR,CAApC;;AACA,YAAI,mBAAJ,EAAyB;AACvB;AACA,eAAK,MAAL,CAAY,aAAZ,CAA0B,UAA1B,CAAqC,mBAArC;AACD;;AAED,QAAA,MAAM,CAAC,MAAD,CAAN,GAAe,KAAf;AACA,aAAK,WAAL,CAAiB,KAAjB;AACA,YAAI,SAAS,IAAI,CAAjB,EAAoB,OAAO,CAAC,MAAR,CAAe,SAAf,EAA0B,CAA1B;AACpB,QAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;AACA;AACD;;AAED,UAAM,IAAI,GAAG,mBAAmB,CAAC,MAAD,CAAhC;AACA,MAAA,mBAAmB,CAAC,MAAD,CAAnB,GAA4B,KAAK,CAAC,MAAlC;;AACA,UAAI,SAAS,IAAI,CAAb,IAAkB,IAAI,KAAK,KAAK,CAAC,MAArC,EAA6C;AAC3C;AACA;AACA,QAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACA,QAAA,eAAe;AACf,eAAO,MAAP;AACD,OAND,MAMO,IAAI,SAAS,GAAG,CAAhB,EAAmB;AACxB,QAAA,OAAO,CAAC,IAAR,CAAa,KAAb;AACD;;AAED,MAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACD;;AAED,IAAA,eAAe;AACf,WAAO,MAAP;AACD,GAtDD;;AAwDA,EAAA,iBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,KAAZ,EAA8B;AAC5B,QAAI,KAAK,CAAC,QAAN,IAAkB,CAAC,KAAK,CAAC,GAA7B,EAAkC;AAClC,QAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,UAAZ,CAAuB,KAAxC;AACA,IAAA,QAAQ,CAAC,IAAT,CAAc,QAAQ,CAAC,cAAT,CAAwB,MAAxB,CAA+B,KAA/B,CAAd;AACD,GAJD;;AAKF,SAAA,iBAAA;AAAC,CA3FD,EAAA","sourcesContent":["/** @packageDocumentation @publicapi @module state */\nimport { inArray, isString, prop } from '../common';\nimport { _StateDeclaration } from './interface';\nimport { StateObject } from './stateObject';\nimport { StateBuilder } from './stateBuilder';\nimport { StateRegistryListener } from './stateRegistry';\nimport { Disposable } from '../interface';\nimport { UIRouter } from '../router';\n\n/** @internalapi */\nexport class StateQueueManager implements Disposable {\n  queue: StateObject[] = [];\n\n  constructor(\n    private router: UIRouter,\n    public states: { [key: string]: StateObject },\n    public builder: StateBuilder,\n    public listeners: StateRegistryListener[]\n  ) {}\n\n  /** @internalapi */\n  dispose() {\n    this.queue = [];\n  }\n\n  register(stateDecl: _StateDeclaration) {\n    const queue = this.queue;\n    const state = StateObject.create(stateDecl);\n    const name = state.name;\n\n    if (!isString(name)) throw new Error('State must have a valid name');\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n      throw new Error(`State '${name}' is already defined`);\n\n    queue.push(state);\n    this.flush();\n\n    return state;\n  }\n\n  flush() {\n    const { queue, states, builder } = this;\n    const registered: StateObject[] = [], // states that got registered\n      orphans: StateObject[] = [], // states that don't yet have a parent registered\n      previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n    const getState = name => this.states.hasOwnProperty(name) && this.states[name];\n    const notifyListeners = () => {\n      if (registered.length) {\n        this.listeners.forEach(listener => listener('registered', registered.map(s => s.self)));\n      }\n    };\n\n    while (queue.length > 0) {\n      const state: StateObject = queue.shift();\n      const name = state.name;\n      const result: StateObject = builder.build(state);\n      const orphanIdx: number = orphans.indexOf(state);\n\n      if (result) {\n        const existingState = getState(name);\n        if (existingState && existingState.name === name) {\n          throw new Error(`State '${name}' is already defined`);\n        }\n\n        const existingFutureState = getState(name + '.**');\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.router.stateRegistry.deregister(existingFutureState);\n        }\n\n        states[name] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      const prev = previousQueueLength[name];\n      previousQueueLength[name] = queue.length;\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        notifyListeners();\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    notifyListeners();\n    return states;\n  }\n\n  attachRoute(state: StateObject) {\n    if (state.abstract || !state.url) return;\n    const rulesApi = this.router.urlService.rules;\n    rulesApi.rule(rulesApi.urlRuleFactory.create(state));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}