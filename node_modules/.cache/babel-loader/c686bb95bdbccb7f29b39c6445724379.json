{"ast":null,"code":"/** @packageDocumentation @publicapi @module state */\nimport { isString } from '../common/predicates';\nimport { values } from '../common/common';\nimport { safeConsole } from '../common/safeConsole';\n\nvar StateMatcher =\n/** @class */\nfunction () {\n  function StateMatcher(_states) {\n    this._states = _states;\n  }\n\n  StateMatcher.prototype.isRelative = function (stateName) {\n    stateName = stateName || '';\n    return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;\n  };\n\n  StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n    if (matchGlob === void 0) {\n      matchGlob = true;\n    }\n\n    if (!stateOrName && stateOrName !== '') return undefined;\n    var isStr = isString(stateOrName);\n    var name = isStr ? stateOrName : stateOrName.name;\n    if (this.isRelative(name)) name = this.resolvePath(name, base);\n    var state = this._states[name];\n\n    if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {\n      return state;\n    } else if (isStr && matchGlob) {\n      var _states = values(this._states);\n\n      var matches = _states.filter(function (_state) {\n        return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name);\n      });\n\n      if (matches.length > 1) {\n        safeConsole.error(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) {\n          return match.name;\n        }));\n      }\n\n      return matches[0];\n    }\n\n    return undefined;\n  };\n\n  StateMatcher.prototype.resolvePath = function (name, base) {\n    if (!base) throw new Error(\"No reference point given for path '\" + name + \"'\");\n    var baseState = this.find(base);\n    var splitName = name.split('.');\n    var pathLength = splitName.length;\n    var i = 0,\n        current = baseState;\n\n    for (; i < pathLength; i++) {\n      if (splitName[i] === '' && i === 0) {\n        current = baseState;\n        continue;\n      }\n\n      if (splitName[i] === '^') {\n        if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n        current = current.parent;\n        continue;\n      }\n\n      break;\n    }\n\n    var relName = splitName.slice(i).join('.');\n    return current.name + (current.name && relName ? '.' : '') + relName;\n  };\n\n  return StateMatcher;\n}();\n\nexport { StateMatcher };","map":{"version":3,"sources":["@uirouter/core/state/stateMatcher.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module state */\nimport { isString } from '../common/predicates';\nimport { StateOrName } from './interface';\nimport { StateObject } from './stateObject';\nimport { values } from '../common/common';\nimport { safeConsole } from '../common/safeConsole';\n\nexport class StateMatcher {\n  constructor(private _states: { [key: string]: StateObject }) {}\n\n  isRelative(stateName: string) {\n    stateName = stateName || '';\n    return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;\n  }\n\n  find(stateOrName: StateOrName, base?: StateOrName, matchGlob = true): StateObject {\n    if (!stateOrName && stateOrName !== '') return undefined;\n    const isStr = isString(stateOrName);\n    let name: string = isStr ? stateOrName : (<any>stateOrName).name;\n\n    if (this.isRelative(name)) name = this.resolvePath(name, base);\n    const state = this._states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    } else if (isStr && matchGlob) {\n      const _states = values(this._states);\n      const matches = _states.filter(\n        _state => _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name)\n      );\n\n      if (matches.length > 1) {\n        safeConsole.error(\n          `stateMatcher.find: Found multiple matches for ${name} using glob: `,\n          matches.map(match => match.name)\n        );\n      }\n      return matches[0];\n    }\n    return undefined;\n  }\n\n  resolvePath(name: string, base: StateOrName) {\n    if (!base) throw new Error(`No reference point given for path '${name}'`);\n\n    const baseState: StateObject = this.find(base);\n\n    const splitName = name.split('.');\n    const pathLength = splitName.length;\n    let i = 0,\n      current = baseState;\n\n    for (; i < pathLength; i++) {\n      if (splitName[i] === '' && i === 0) {\n        current = baseState;\n        continue;\n      }\n      if (splitName[i] === '^') {\n        if (!current.parent) throw new Error(`Path '${name}' not valid for state '${baseState.name}'`);\n        current = current.parent;\n        continue;\n      }\n      break;\n    }\n    const relName = splitName.slice(i).join('.');\n    return current.name + (current.name && relName ? '.' : '') + relName;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}