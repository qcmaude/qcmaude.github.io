{"ast":null,"code":"/** @packageDocumentation @publicapi @module state */\nimport { applyPairs, extend, identity, inherit, mapObj, noop, omit, tail, values, copy } from '../common/common';\nimport { isArray, isDefined, isFunction, isString } from '../common/predicates';\nimport { stringify } from '../common/strings';\nimport { is, pattern, pipe, prop, val } from '../common/hof';\nimport { Resolvable } from '../resolve/resolvable';\nimport { services } from '../common/coreservices';\n\nvar parseUrl = function (url) {\n  if (!isString(url)) return false;\n  var root = url.charAt(0) === '^';\n  return {\n    val: root ? url.substring(1) : url,\n    root: root\n  };\n};\n\nfunction nameBuilder(state) {\n  return state.name;\n}\n\nfunction selfBuilder(state) {\n  state.self.$$state = function () {\n    return state;\n  };\n\n  return state.self;\n}\n\nfunction dataBuilder(state) {\n  if (state.parent && state.parent.data) {\n    state.data = state.self.data = inherit(state.parent.data, state.data);\n  }\n\n  return state.data;\n}\n\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n  return function urlBuilder(stateObject) {\n    var stateDec = stateObject.self; // For future states, i.e., states whose name ends with `.**`,\n    // match anything that starts with the url prefix\n\n    if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n      var newStateDec = {};\n      copy(stateDec, newStateDec);\n      newStateDec.url += '{remainder:any}'; // match any path (.*)\n\n      stateDec = newStateDec;\n    }\n\n    var parent = stateObject.parent;\n    var parsed = parseUrl(stateDec.url);\n    var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n      state: stateDec\n    });\n    if (!url) return null;\n    if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error(\"Invalid url '\" + url + \"' in state '\" + stateObject + \"'\");\n    return parsed && parsed.root ? url : (parent && parent.navigable || root()).url.append(url);\n  };\n};\n\nvar getNavigableBuilder = function (isRoot) {\n  return function navigableBuilder(state) {\n    return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;\n  };\n};\n\nvar getParamsBuilder = function (paramFactory) {\n  return function paramsBuilder(state) {\n    var makeConfigParam = function (config, id) {\n      return paramFactory.fromConfig(id, null, state.self);\n    };\n\n    var urlParams = state.url && state.url.parameters({\n      inherit: false\n    }) || [];\n    var nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));\n    return urlParams.concat(nonUrlParams).map(function (p) {\n      return [p.id, p];\n    }).reduce(applyPairs, {});\n  };\n};\n\nfunction pathBuilder(state) {\n  return state.parent ? state.parent.path.concat(state) :\n  /*root*/\n  [state];\n}\n\nfunction includesBuilder(state) {\n  var includes = state.parent ? extend({}, state.parent.includes) : {};\n  includes[state.name] = true;\n  return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\n\n\nexport function resolvablesBuilder(state) {\n  /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n  var objects2Tuples = function (resolveObj, resolvePolicies) {\n    return Object.keys(resolveObj || {}).map(function (token) {\n      return {\n        token: token,\n        val: resolveObj[token],\n        deps: undefined,\n        policy: resolvePolicies[token]\n      };\n    });\n  };\n  /** fetch DI annotations from a function or ng1-style array */\n\n\n  var annotate = function (fn) {\n    var $injector = services.$injector; // ng1 doesn't have an $injector until runtime.\n    // If the $injector doesn't exist, use \"deferred\" literal as a\n    // marker indicating they should be annotated when runtime starts\n\n    return fn['$inject'] || $injector && $injector.annotate(fn, $injector.strictDi) || 'deferred';\n  };\n  /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\n\n  var isResolveLiteral = function (obj) {\n    return !!(obj.token && obj.resolveFn);\n  };\n  /** true if the object looks like a provide literal, or a ng2 Provider */\n\n\n  var isLikeNg2Provider = function (obj) {\n    return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));\n  };\n  /** true if the object looks like a tuple from obj2Tuples */\n\n\n  var isTupleFromObj = function (obj) {\n    return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));\n  };\n  /** extracts the token from a Provider or provide literal */\n\n\n  var getToken = function (p) {\n    return p.provide || p.token;\n  }; // prettier-ignore: Given a literal resolve or provider object, returns a Resolvable\n\n\n  var literal2Resolvable = pattern([[prop('resolveFn'), function (p) {\n    return new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy);\n  }], [prop('useFactory'), function (p) {\n    return new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy);\n  }], [prop('useClass'), function (p) {\n    return new Resolvable(getToken(p), function () {\n      return new p.useClass();\n    }, [], p.policy);\n  }], [prop('useValue'), function (p) {\n    return new Resolvable(getToken(p), function () {\n      return p.useValue;\n    }, [], p.policy, p.useValue);\n  }], [prop('useExisting'), function (p) {\n    return new Resolvable(getToken(p), identity, [p.useExisting], p.policy);\n  }]]); // prettier-ignore\n\n  var tuple2Resolvable = pattern([[pipe(prop('val'), isString), function (tuple) {\n    return new Resolvable(tuple.token, identity, [tuple.val], tuple.policy);\n  }], [pipe(prop('val'), isArray), function (tuple) {\n    return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy);\n  }], [pipe(prop('val'), isFunction), function (tuple) {\n    return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy);\n  }]]); // prettier-ignore\n\n  var item2Resolvable = pattern([[is(Resolvable), function (r) {\n    return r;\n  }], [isResolveLiteral, literal2Resolvable], [isLikeNg2Provider, literal2Resolvable], [isTupleFromObj, tuple2Resolvable], [val(true), function (obj) {\n    throw new Error('Invalid resolve value: ' + stringify(obj));\n  }]]); // If resolveBlock is already an array, use it as-is.\n  // Otherwise, assume it's an object and convert to an Array of tuples\n\n  var decl = state.resolve;\n  var items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n  return items.map(item2Resolvable);\n}\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\n\nvar StateBuilder =\n/** @class */\nfunction () {\n  function StateBuilder(matcher, urlMatcherFactory) {\n    this.matcher = matcher;\n    var self = this;\n\n    var root = function () {\n      return matcher.find('');\n    };\n\n    var isRoot = function (state) {\n      return state.name === '';\n    };\n\n    function parentBuilder(state) {\n      if (isRoot(state)) return null;\n      return matcher.find(self.parentName(state)) || root();\n    }\n\n    this.builders = {\n      name: [nameBuilder],\n      self: [selfBuilder],\n      parent: [parentBuilder],\n      data: [dataBuilder],\n      // Build a URLMatcher if necessary, either via a relative or absolute URL\n      url: [getUrlBuilder(urlMatcherFactory, root)],\n      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n      navigable: [getNavigableBuilder(isRoot)],\n      params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n      // Each framework-specific ui-router implementation should define its own `views` builder\n      // e.g., src/ng1/statebuilders/views.ts\n      views: [],\n      // Keep a full path from the root down to this state as this is needed for state activation.\n      path: [pathBuilder],\n      // Speed up $state.includes() as it's used a lot\n      includes: [includesBuilder],\n      resolvables: [resolvablesBuilder]\n    };\n  }\n  /**\n   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n   * More than one BuilderFunction can be registered for a given property.\n   *\n   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n   *\n   * @param name The name of the State property being registered for.\n   * @param fn The BuilderFunction which will be used to build the State property\n   * @returns a function which deregisters the BuilderFunction\n   */\n\n\n  StateBuilder.prototype.builder = function (name, fn) {\n    var builders = this.builders;\n    var array = builders[name] || []; // Backwards compat: if only one builder exists, return it, else return whole arary.\n\n    if (isString(name) && !isDefined(fn)) return array.length > 1 ? array : array[0];\n    if (!isString(name) || !isFunction(fn)) return;\n    builders[name] = array;\n    builders[name].push(fn);\n    return function () {\n      return builders[name].splice(builders[name].indexOf(fn, 1)) && null;\n    };\n  };\n  /**\n   * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n   * properties and API built.\n   *\n   * @param state an uninitialized State object\n   * @returns the built State object\n   */\n\n\n  StateBuilder.prototype.build = function (state) {\n    var _a = this,\n        matcher = _a.matcher,\n        builders = _a.builders;\n\n    var parent = this.parentName(state);\n\n    if (parent && !matcher.find(parent, undefined, false)) {\n      return null;\n    }\n\n    for (var key in builders) {\n      if (!builders.hasOwnProperty(key)) continue;\n      var chain = builders[key].reduce(function (parentFn, step) {\n        return function (_state) {\n          return step(_state, parentFn);\n        };\n      }, noop);\n      state[key] = chain(state);\n    }\n\n    return state;\n  };\n\n  StateBuilder.prototype.parentName = function (state) {\n    // name = 'foo.bar.baz.**'\n    var name = state.name || ''; // segments = ['foo', 'bar', 'baz', '.**']\n\n    var segments = name.split('.'); // segments = ['foo', 'bar', 'baz']\n\n    var lastSegment = segments.pop(); // segments = ['foo', 'bar'] (ignore .** segment for future states)\n\n    if (lastSegment === '**') segments.pop();\n\n    if (segments.length) {\n      if (state.parent) {\n        throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n      } // 'foo.bar'\n\n\n      return segments.join('.');\n    }\n\n    if (!state.parent) return '';\n    return isString(state.parent) ? state.parent : state.parent.name;\n  };\n\n  StateBuilder.prototype.name = function (state) {\n    var name = state.name;\n    if (name.indexOf('.') !== -1 || !state.parent) return name;\n    var parentName = isString(state.parent) ? state.parent : state.parent.name;\n    return parentName ? parentName + '.' + name : name;\n  };\n\n  return StateBuilder;\n}();\n\nexport { StateBuilder };","map":{"version":3,"sources":["@uirouter/core/state/stateBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module state */\nimport { applyPairs, extend, identity, inherit, mapObj, noop, Obj, omit, tail, values, copy } from '../common/common';\nimport { isArray, isDefined, isFunction, isString } from '../common/predicates';\nimport { stringify } from '../common/strings';\nimport { is, pattern, pipe, prop, val } from '../common/hof';\nimport { StateDeclaration } from './interface';\n\nimport { StateObject } from './stateObject';\nimport { StateMatcher } from './stateMatcher';\nimport { Param } from '../params/param';\nimport { UrlMatcherFactory } from '../url/urlMatcherFactory';\nimport { UrlMatcher } from '../url/urlMatcher';\nimport { Resolvable } from '../resolve/resolvable';\nimport { services } from '../common/coreservices';\nimport { ResolvePolicy } from '../resolve/interface';\nimport { ParamDeclaration } from '../params';\nimport { ParamFactory } from '../url';\n\nconst parseUrl = (url: string): any => {\n  if (!isString(url)) return false;\n  const root = url.charAt(0) === '^';\n  return { val: root ? url.substring(1) : url, root };\n};\n\nexport type BuilderFunction = (state: StateObject, parent?: BuilderFunction) => any;\n\ninterface Builders {\n  [key: string]: BuilderFunction[];\n\n  name: BuilderFunction[];\n  parent: BuilderFunction[];\n  data: BuilderFunction[];\n  url: BuilderFunction[];\n  navigable: BuilderFunction[];\n  params: BuilderFunction[];\n  views: BuilderFunction[];\n  path: BuilderFunction[];\n  includes: BuilderFunction[];\n  resolvables: BuilderFunction[];\n}\n\nfunction nameBuilder(state: StateObject) {\n  return state.name;\n}\n\nfunction selfBuilder(state: StateObject) {\n  state.self.$$state = () => state;\n  return state.self;\n}\n\nfunction dataBuilder(state: StateObject) {\n  if (state.parent && state.parent.data) {\n    state.data = state.self.data = inherit(state.parent.data, state.data);\n  }\n  return state.data;\n}\n\nconst getUrlBuilder = ($urlMatcherFactoryProvider: UrlMatcherFactory, root: () => StateObject) =>\n  function urlBuilder(stateObject: StateObject) {\n    let stateDec: StateDeclaration = stateObject.self;\n\n    // For future states, i.e., states whose name ends with `.**`,\n    // match anything that starts with the url prefix\n    if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n      const newStateDec: StateDeclaration = {};\n      copy(stateDec, newStateDec);\n      newStateDec.url += '{remainder:any}'; // match any path (.*)\n      stateDec = newStateDec;\n    }\n\n    const parent = stateObject.parent;\n    const parsed = parseUrl(stateDec.url);\n    const url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, { state: stateDec });\n\n    if (!url) return null;\n    if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error(`Invalid url '${url}' in state '${stateObject}'`);\n    return parsed && parsed.root ? url : ((parent && parent.navigable) || root()).url.append(<UrlMatcher>url);\n  };\n\nconst getNavigableBuilder = (isRoot: (state: StateObject) => boolean) =>\n  function navigableBuilder(state: StateObject) {\n    return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;\n  };\n\nconst getParamsBuilder = (paramFactory: ParamFactory) =>\n  function paramsBuilder(state: StateObject): { [key: string]: Param } {\n    const makeConfigParam = (config: ParamDeclaration, id: string) => paramFactory.fromConfig(id, null, state.self);\n    const urlParams: Param[] = (state.url && state.url.parameters({ inherit: false })) || [];\n    const nonUrlParams: Param[] = values(mapObj(omit(state.params || {}, urlParams.map(prop('id'))), makeConfigParam));\n    return urlParams\n      .concat(nonUrlParams)\n      .map(p => [p.id, p])\n      .reduce(applyPairs, {});\n  };\n\nfunction pathBuilder(state: StateObject) {\n  return state.parent ? state.parent.path.concat(state) : /*root*/ [state];\n}\n\nfunction includesBuilder(state: StateObject) {\n  const includes = state.parent ? extend({}, state.parent.includes) : {};\n  includes[state.name] = true;\n  return includes;\n}\n\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nexport function resolvablesBuilder(state: StateObject): Resolvable[] {\n  interface Tuple {\n    token: any;\n    val: any;\n    deps: any[];\n    policy: ResolvePolicy;\n  }\n\n  /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n  const objects2Tuples = (resolveObj: Obj, resolvePolicies: { [key: string]: ResolvePolicy }) =>\n    Object.keys(resolveObj || {}).map(token => ({\n      token,\n      val: resolveObj[token],\n      deps: undefined,\n      policy: resolvePolicies[token],\n    }));\n\n  /** fetch DI annotations from a function or ng1-style array */\n  const annotate = (fn: Function) => {\n    const $injector = services.$injector;\n    // ng1 doesn't have an $injector until runtime.\n    // If the $injector doesn't exist, use \"deferred\" literal as a\n    // marker indicating they should be annotated when runtime starts\n    return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || <any>'deferred';\n  };\n\n  /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n  const isResolveLiteral = (obj: any) => !!(obj.token && obj.resolveFn);\n\n  /** true if the object looks like a provide literal, or a ng2 Provider */\n  const isLikeNg2Provider = (obj: any) =>\n    !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));\n\n  /** true if the object looks like a tuple from obj2Tuples */\n  const isTupleFromObj = (obj: any) =>\n    !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));\n\n  /** extracts the token from a Provider or provide literal */\n  const getToken = (p: any) => p.provide || p.token;\n\n  // prettier-ignore: Given a literal resolve or provider object, returns a Resolvable\n  const literal2Resolvable = pattern([\n    [prop('resolveFn'), p => new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy)],\n    [prop('useFactory'), p => new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy)],\n    [prop('useClass'), p => new Resolvable(getToken(p), () => new (<any>p.useClass)(), [], p.policy)],\n    [prop('useValue'), p => new Resolvable(getToken(p), () => p.useValue, [], p.policy, p.useValue)],\n    [prop('useExisting'), p => new Resolvable(getToken(p), identity, [p.useExisting], p.policy)],\n  ]);\n\n  // prettier-ignore\n  const tuple2Resolvable = pattern([\n    [pipe(prop('val'), isString),   (tuple: Tuple) => new Resolvable(tuple.token, identity, [tuple.val], tuple.policy)],\n    [pipe(prop('val'), isArray),    (tuple: Tuple) => new Resolvable(tuple.token, tail(<any[]>tuple.val), tuple.val.slice(0, -1), tuple.policy)],\n    [pipe(prop('val'), isFunction), (tuple: Tuple) => new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy)],\n  ]);\n\n  // prettier-ignore\n  const item2Resolvable = <(obj: any) => Resolvable>pattern([\n    [is(Resolvable), (r: Resolvable) => r],\n    [isResolveLiteral, literal2Resolvable],\n    [isLikeNg2Provider, literal2Resolvable],\n    [isTupleFromObj, tuple2Resolvable],\n    [val(true), (obj: any) => { throw new Error('Invalid resolve value: ' + stringify(obj)); }, ],\n  ]);\n\n  // If resolveBlock is already an array, use it as-is.\n  // Otherwise, assume it's an object and convert to an Array of tuples\n  const decl = state.resolve;\n  const items: any[] = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n  return items.map(item2Resolvable);\n}\n\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nexport class StateBuilder {\n  /** An object that contains all the BuilderFunctions registered, key'd by the name of the State property they build */\n  private builders: Builders;\n\n  constructor(private matcher: StateMatcher, urlMatcherFactory: UrlMatcherFactory) {\n    const self = this;\n\n    const root = () => matcher.find('');\n    const isRoot = (state: StateObject) => state.name === '';\n\n    function parentBuilder(state: StateObject) {\n      if (isRoot(state)) return null;\n      return matcher.find(self.parentName(state)) || root();\n    }\n\n    this.builders = {\n      name: [nameBuilder],\n      self: [selfBuilder],\n      parent: [parentBuilder],\n      data: [dataBuilder],\n      // Build a URLMatcher if necessary, either via a relative or absolute URL\n      url: [getUrlBuilder(urlMatcherFactory, root)],\n      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n      navigable: [getNavigableBuilder(isRoot)],\n      params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n      // Each framework-specific ui-router implementation should define its own `views` builder\n      // e.g., src/ng1/statebuilders/views.ts\n      views: [],\n      // Keep a full path from the root down to this state as this is needed for state activation.\n      path: [pathBuilder],\n      // Speed up $state.includes() as it's used a lot\n      includes: [includesBuilder],\n      resolvables: [resolvablesBuilder],\n    };\n  }\n\n  /**\n   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n   * More than one BuilderFunction can be registered for a given property.\n   *\n   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n   *\n   * @param name The name of the State property being registered for.\n   * @param fn The BuilderFunction which will be used to build the State property\n   * @returns a function which deregisters the BuilderFunction\n   */\n  builder(name: string, fn: BuilderFunction): BuilderFunction | BuilderFunction[] | Function {\n    const builders = this.builders;\n    const array = builders[name] || [];\n    // Backwards compat: if only one builder exists, return it, else return whole arary.\n    if (isString(name) && !isDefined(fn)) return array.length > 1 ? array : array[0];\n    if (!isString(name) || !isFunction(fn)) return;\n\n    builders[name] = array;\n    builders[name].push(fn);\n    return () => builders[name].splice(builders[name].indexOf(fn, 1)) && null;\n  }\n\n  /**\n   * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n   * properties and API built.\n   *\n   * @param state an uninitialized State object\n   * @returns the built State object\n   */\n  build(state: StateObject): StateObject {\n    const { matcher, builders } = this;\n    const parent = this.parentName(state);\n\n    if (parent && !matcher.find(parent, undefined, false)) {\n      return null;\n    }\n\n    for (const key in builders) {\n      if (!builders.hasOwnProperty(key)) continue;\n      const chain = builders[key].reduce(\n        (parentFn: BuilderFunction, step: BuilderFunction) => _state => step(_state, parentFn),\n        noop\n      );\n      state[key] = chain(state);\n    }\n    return state;\n  }\n\n  parentName(state: StateObject) {\n    // name = 'foo.bar.baz.**'\n    const name = state.name || '';\n    // segments = ['foo', 'bar', 'baz', '.**']\n    const segments = name.split('.');\n    // segments = ['foo', 'bar', 'baz']\n    const lastSegment = segments.pop();\n    // segments = ['foo', 'bar'] (ignore .** segment for future states)\n    if (lastSegment === '**') segments.pop();\n\n    if (segments.length) {\n      if (state.parent) {\n        throw new Error(`States that specify the 'parent:' property should not have a '.' in their name (${name})`);\n      }\n\n      // 'foo.bar'\n      return segments.join('.');\n    }\n\n    if (!state.parent) return '';\n    return isString(state.parent) ? state.parent : state.parent.name;\n  }\n\n  name(state: StateObject) {\n    const name = state.name;\n    if (name.indexOf('.') !== -1 || !state.parent) return name;\n\n    const parentName = isString(state.parent) ? state.parent : state.parent.name;\n    return parentName ? parentName + '.' + name : name;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}