{"ast":null,"code":"import { UrlMatcher } from './urlMatcher';\nimport { isString, isDefined, isFunction } from '../common/predicates';\nimport { identity, extend } from '../common/common';\nimport { is, or, pattern } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\n\nvar UrlRuleFactory =\n/** @class */\nfunction () {\n  function UrlRuleFactory(router) {\n    this.router = router;\n  }\n\n  UrlRuleFactory.prototype.compile = function (str) {\n    return this.router.urlMatcherFactory.compile(str);\n  };\n\n  UrlRuleFactory.prototype.create = function (what, handler) {\n    var _this = this;\n\n    var isState = StateObject.isState,\n        isStateDeclaration = StateObject.isStateDeclaration;\n    var makeRule = pattern([[isString, function (_what) {\n      return makeRule(_this.compile(_what));\n    }], [is(UrlMatcher), function (_what) {\n      return _this.fromUrlMatcher(_what, handler);\n    }], [or(isState, isStateDeclaration), function (_what) {\n      return _this.fromState(_what, _this.router);\n    }], [is(RegExp), function (_what) {\n      return _this.fromRegExp(_what, handler);\n    }], [isFunction, function (_what) {\n      return new BaseUrlRule(_what, handler);\n    }]]);\n    var rule = makeRule(what);\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n    return rule;\n  };\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   */\n\n\n  UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n    var _handler = handler;\n    if (isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);\n    if (is(UrlMatcher)(handler)) _handler = function (match) {\n      return handler.format(match);\n    };\n\n    function matchUrlParamters(url) {\n      var params = urlMatcher.exec(url.path, url.search, url.hash);\n      return urlMatcher.validates(params) && params;\n    } // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n\n\n    function matchPriority(params) {\n      var optional = urlMatcher.parameters().filter(function (param) {\n        return param.isOptional;\n      });\n      if (!optional.length) return 0.000001;\n      var matched = optional.filter(function (param) {\n        return params[param.id];\n      });\n      return matched.length / optional.length;\n    }\n\n    var details = {\n      urlMatcher: urlMatcher,\n      matchPriority: matchPriority,\n      type: 'URLMATCHER'\n    };\n    return extend(new BaseUrlRule(matchUrlParamters, _handler), details);\n  };\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   */\n\n\n  UrlRuleFactory.prototype.fromState = function (stateOrDecl, router) {\n    var state = StateObject.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl;\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n\n    var handler = function (match) {\n      var $state = router.stateService;\n      var globals = router.globals;\n\n      if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n        $state.transitionTo(state, match, {\n          inherit: true,\n          source: 'url'\n        });\n      }\n    };\n\n    var details = {\n      state: state,\n      type: 'STATE'\n    };\n    return extend(this.fromUrlMatcher(state.url, handler), details);\n  };\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   */\n\n\n  UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n    if (regexp.global || regexp.sticky) throw new Error('Rule RegExp must not be global or sticky');\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n\n    var redirectUrlTo = function (match) {\n      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n      return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n        return match[what === '$' ? 0 : Number(what)];\n      });\n    };\n\n    var _handler = isString(handler) ? redirectUrlTo : handler;\n\n    var matchParamsFromRegexp = function (url) {\n      return regexp.exec(url.path);\n    };\n\n    var details = {\n      regexp: regexp,\n      type: 'REGEXP'\n    };\n    return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);\n  };\n\n  UrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) {\n      return isDefined(obj[key]);\n    });\n  };\n\n  return UrlRuleFactory;\n}();\n\nexport { UrlRuleFactory };\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\n\nvar BaseUrlRule =\n/** @class */\nfunction () {\n  function BaseUrlRule(match, handler) {\n    var _this = this;\n\n    this.match = match;\n    this.type = 'RAW';\n\n    this.matchPriority = function (match) {\n      return 0 - _this.$id;\n    };\n\n    this.handler = handler || identity;\n  }\n\n  return BaseUrlRule;\n}();\n\nexport { BaseUrlRule };","map":{"version":3,"sources":["@uirouter/core/url/urlRule.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module url */\nimport { StateDeclaration } from '../state';\nimport { UrlMatcher } from './urlMatcher';\nimport { isString, isDefined, isFunction } from '../common/predicates';\nimport { UIRouter } from '../router';\nimport { identity, extend } from '../common/common';\nimport { is, or, pattern } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\nimport { RawParams } from '../params/interface';\nimport {\n  UrlRule,\n  UrlRuleMatchFn,\n  UrlRuleHandlerFn,\n  UrlRuleType,\n  UrlParts,\n  MatcherUrlRule,\n  StateRule,\n  RegExpRule,\n} from './interface';\n\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nexport class UrlRuleFactory {\n  static isUrlRule = (obj) => obj && ['type', 'match', 'handler'].every((key) => isDefined(obj[key]));\n\n  constructor(public router: UIRouter) {}\n\n  compile(str: string) {\n    return this.router.urlMatcherFactory.compile(str);\n  }\n\n  create(\n    what: string | UrlMatcher | StateObject | StateDeclaration | RegExp | UrlRuleMatchFn,\n    handler?: string | UrlRuleHandlerFn\n  ): UrlRule {\n    const { isState, isStateDeclaration } = StateObject;\n    const makeRule = pattern([\n      [isString, (_what: string) => makeRule(this.compile(_what))],\n      [is(UrlMatcher), (_what: UrlMatcher) => this.fromUrlMatcher(_what, handler)],\n      [or(isState, isStateDeclaration), (_what: StateObject | StateDeclaration) => this.fromState(_what, this.router)],\n      [is(RegExp), (_what: RegExp) => this.fromRegExp(_what, handler)],\n      [isFunction, (_what: UrlRuleMatchFn) => new BaseUrlRule(_what, handler as UrlRuleHandlerFn)],\n    ]);\n\n    const rule = makeRule(what);\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n    return rule;\n  }\n\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   */\n  fromUrlMatcher(urlMatcher: UrlMatcher, handler: string | UrlMatcher | UrlRuleHandlerFn): MatcherUrlRule {\n    let _handler: UrlRuleHandlerFn = handler as any;\n    if (isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);\n    if (is(UrlMatcher)(handler)) _handler = (match: RawParams) => (handler as UrlMatcher).format(match);\n\n    function matchUrlParamters(url: UrlParts): RawParams {\n      const params = urlMatcher.exec(url.path, url.search, url.hash);\n      return urlMatcher.validates(params) && params;\n    }\n\n    // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n    function matchPriority(params: RawParams): number {\n      const optional = urlMatcher.parameters().filter((param) => param.isOptional);\n      if (!optional.length) return 0.000001;\n      const matched = optional.filter((param) => params[param.id]);\n      return matched.length / optional.length;\n    }\n\n    const details = { urlMatcher, matchPriority, type: 'URLMATCHER' };\n    return extend(new BaseUrlRule(matchUrlParamters, _handler), details) as MatcherUrlRule;\n  }\n\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   */\n  fromState(stateOrDecl: StateObject | StateDeclaration, router: UIRouter): StateRule {\n    const state = StateObject.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl;\n\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n    const handler = (match: RawParams) => {\n      const $state = router.stateService;\n      const globals = router.globals;\n      if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n        $state.transitionTo(state, match, { inherit: true, source: 'url' });\n      }\n    };\n\n    const details = { state, type: 'STATE' };\n    return extend(this.fromUrlMatcher(state.url, handler), details) as StateRule;\n  }\n\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   */\n  fromRegExp(regexp: RegExp, handler: string | UrlRuleHandlerFn): RegExpRule {\n    if (regexp.global || regexp.sticky) throw new Error('Rule RegExp must not be global or sticky');\n\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n    const redirectUrlTo = (match: RegExpExecArray) =>\n      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n      (handler as string).replace(/\\$(\\$|\\d{1,2})/, (m, what) => match[what === '$' ? 0 : Number(what)]);\n\n    const _handler = isString(handler) ? redirectUrlTo : handler;\n\n    const matchParamsFromRegexp = (url: UrlParts): RegExpExecArray => regexp.exec(url.path);\n\n    const details = { regexp, type: 'REGEXP' };\n    return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details) as RegExpRule;\n  }\n}\n\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nexport class BaseUrlRule implements UrlRule {\n  $id: number;\n  priority: number;\n  _group: number;\n  type: UrlRuleType = 'RAW';\n  handler: UrlRuleHandlerFn;\n  matchPriority = (match) => 0 - this.$id;\n\n  constructor(public match: UrlRuleMatchFn, handler?: UrlRuleHandlerFn) {\n    this.handler = handler || identity;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}