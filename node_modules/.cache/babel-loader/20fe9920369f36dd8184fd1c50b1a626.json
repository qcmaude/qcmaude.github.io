{"ast":null,"code":"/** @packageDocumentation @publicapi @module state */\nimport { createProxyFunctions, defaults, extend, inArray, noop, removeFrom, silenceUncaughtInPromise, silentRejection } from '../common/common';\nimport { isDefined, isObject, isString } from '../common/predicates';\nimport { Queue } from '../common/queue';\nimport { services } from '../common/coreservices';\nimport { PathUtils } from '../path/pathUtils';\nimport { PathNode } from '../path/pathNode';\nimport { defaultTransOpts } from '../transition/transitionService';\nimport { Rejection, RejectType } from '../transition/rejectFactory';\nimport { TargetState } from './targetState';\nimport { Param } from '../params/param';\nimport { Glob } from '../common/glob';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { lazyLoadState } from '../hooks/lazyLoad';\nimport { not, val } from '../common/hof';\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\n\nvar StateService =\n/** @class */\nfunction () {\n  /** @internalapi */\n  function StateService(\n  /** @hidden */\n  router) {\n    this.router = router;\n    /** @internalapi */\n\n    this.invalidCallbacks = [];\n    /** @hidden */\n\n    this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n      if ($error$ instanceof Error && $error$.stack) {\n        console.error($error$);\n        console.error($error$.stack);\n      } else if ($error$ instanceof Rejection) {\n        console.error($error$.toString());\n        if ($error$.detail && $error$.detail.stack) console.error($error$.detail.stack);\n      } else {\n        console.error($error$);\n      }\n    };\n\n    var getters = ['current', '$current', 'params', 'transition'];\n    var boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));\n    createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);\n  }\n\n  Object.defineProperty(StateService.prototype, \"transition\", {\n    /**\n     * The [[Transition]] currently in progress (or null)\n     *\n     * This is a passthrough through to [[UIRouterGlobals.transition]]\n     */\n    get: function () {\n      return this.router.globals.transition;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"params\", {\n    /**\n     * The latest successful state parameters\n     *\n     * This is a passthrough through to [[UIRouterGlobals.params]]\n     */\n    get: function () {\n      return this.router.globals.params;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"current\", {\n    /**\n     * The current [[StateDeclaration]]\n     *\n     * This is a passthrough through to [[UIRouterGlobals.current]]\n     */\n    get: function () {\n      return this.router.globals.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"$current\", {\n    /**\n     * The current [[StateObject]]\n     *\n     * This is a passthrough through to [[UIRouterGlobals.$current]]\n     */\n    get: function () {\n      return this.router.globals.$current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @internalapi */\n\n  StateService.prototype.dispose = function () {\n    this.defaultErrorHandler(noop);\n    this.invalidCallbacks = [];\n  };\n  /**\n   * Handler for when [[transitionTo]] is called with an invalid state.\n   *\n   * Invokes the [[onInvalid]] callbacks, in natural order.\n   * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n   * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n   *\n   * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n   *\n   * @internalapi\n   */\n\n\n  StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n    var _this = this;\n\n    var fromState = PathUtils.makeTargetState(this.router.stateRegistry, fromPath);\n    var globals = this.router.globals;\n\n    var latestThing = function () {\n      return globals.transitionHistory.peekTail();\n    };\n\n    var latest = latestThing();\n    var callbackQueue = new Queue(this.invalidCallbacks.slice());\n    var injector = new ResolveContext(fromPath).injector();\n\n    var checkForRedirect = function (result) {\n      if (!(result instanceof TargetState)) {\n        return;\n      }\n\n      var target = result; // Recreate the TargetState, in case the state is now defined.\n\n      target = _this.target(target.identifier(), target.params(), target.options());\n\n      if (!target.valid()) {\n        return Rejection.invalid(target.error()).toPromise();\n      }\n\n      if (latestThing() !== latest) {\n        return Rejection.superseded().toPromise();\n      }\n\n      return _this.transitionTo(target.identifier(), target.params(), target.options());\n    };\n\n    function invokeNextCallback() {\n      var nextCallback = callbackQueue.dequeue();\n      if (nextCallback === undefined) return Rejection.invalid(toState.error()).toPromise();\n      var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));\n      return callbackResult.then(checkForRedirect).then(function (result) {\n        return result || invokeNextCallback();\n      });\n    }\n\n    return invokeNextCallback();\n  };\n  /**\n   * Registers an Invalid State handler\n   *\n   * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n   * has been called with an invalid state reference parameter\n   *\n   * Example:\n   * ```js\n   * stateService.onInvalid(function(to, from, injector) {\n   *   if (to.name() === 'foo') {\n   *     let lazyLoader = injector.get('LazyLoadService');\n   *     return lazyLoader.load('foo')\n   *         .then(() => stateService.target('foo'));\n   *   }\n   * });\n   * ```\n   *\n   * @param {function} callback invoked when the toState is invalid\n   *   This function receives the (invalid) toState, the fromState, and an injector.\n   *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n   *   If one is returned, it is treated as a redirect.\n   *\n   * @returns a function which deregisters the callback\n   */\n\n\n  StateService.prototype.onInvalid = function (callback) {\n    this.invalidCallbacks.push(callback);\n    return function deregisterListener() {\n      removeFrom(this.invalidCallbacks)(callback);\n    }.bind(this);\n  };\n  /**\n   * Reloads the current state\n   *\n   * A method that force reloads the current state, or a partial state hierarchy.\n   * All resolves are re-resolved, and components reinstantiated.\n   *\n   * #### Example:\n   * ```js\n   * let app angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.reload = function(){\n   *     $state.reload();\n   *   }\n   * });\n   * ```\n   *\n   * Note: `reload()` is just an alias for:\n   *\n   * ```js\n   * $state.transitionTo($state.current, $state.params, {\n   *   reload: true, inherit: false\n   * });\n   * ```\n   *\n   * @param reloadState A state name or a state object.\n   *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n   *\n   * #### Example:\n   * ```js\n   * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n   * //and current state is 'contacts.detail.item'\n   * let app angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.reload = function(){\n   *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n   *     $state.reload('contact.detail');\n   *   }\n   * });\n   * ```\n   *\n   * @returns A promise representing the state of the new transition. See [[StateService.go]]\n   */\n\n\n  StateService.prototype.reload = function (reloadState) {\n    return this.transitionTo(this.current, this.params, {\n      reload: isDefined(reloadState) ? reloadState : true,\n      inherit: false,\n      notify: false\n    });\n  };\n  /**\n   * Transition to a different state and/or parameters\n   *\n   * Convenience method for transitioning to a new state.\n   *\n   * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n   * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n   * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n   * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n   * inherit from the current parameter values (because of `inherit: true`).\n   *\n   * #### Example:\n   * ```js\n   * let app = angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.changeState = function () {\n   *     $state.go('contact.detail');\n   *   };\n   * });\n   * ```\n   *\n   * @param to Absolute state name, state object, or relative state path (relative to current state).\n   *\n   * Some examples:\n   *\n   * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n   * - `$state.go('^')` - will go to the parent state\n   * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n   * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n   *\n   * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n   *\n   *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n   *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n   *\n   * @param options Transition options\n   *\n   * @returns {promise} A promise representing the state of the new transition.\n   */\n\n\n  StateService.prototype.go = function (to, params, options) {\n    var defautGoOpts = {\n      relative: this.$current,\n      inherit: true\n    };\n    var transOpts = defaults(options, defautGoOpts, defaultTransOpts);\n    return this.transitionTo(to, params, transOpts);\n  };\n  /**\n   * Creates a [[TargetState]]\n   *\n   * This is a factory method for creating a TargetState\n   *\n   * This may be returned from a Transition Hook to redirect a transition, for example.\n   */\n\n\n  StateService.prototype.target = function (identifier, params, options) {\n    if (options === void 0) {\n      options = {};\n    } // If we're reloading, find the state object to reload from\n\n\n    if (isObject(options.reload) && !options.reload.name) throw new Error('Invalid reload state object');\n    var reg = this.router.stateRegistry;\n    options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n    if (options.reload && !options.reloadState) throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n    return new TargetState(this.router.stateRegistry, identifier, params, options);\n  };\n\n  StateService.prototype.getCurrentPath = function () {\n    var _this = this;\n\n    var globals = this.router.globals;\n    var latestSuccess = globals.successfulTransitions.peekTail();\n\n    var rootPath = function () {\n      return [new PathNode(_this.router.stateRegistry.root())];\n    };\n\n    return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n  };\n  /**\n   * Low-level method for transitioning to a new state.\n   *\n   * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n   *\n   * #### Example:\n   * ```js\n   * let app = angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.changeState = function () {\n   *     $state.transitionTo('contact.detail');\n   *   };\n   * });\n   * ```\n   *\n   * @param to State name or state object.\n   * @param toParams A map of the parameters that will be sent to the state,\n   *      will populate $stateParams.\n   * @param options Transition options\n   *\n   * @returns A promise representing the state of the new transition. See [[go]]\n   */\n\n\n  StateService.prototype.transitionTo = function (to, toParams, options) {\n    var _this = this;\n\n    if (toParams === void 0) {\n      toParams = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var router = this.router;\n    var globals = router.globals;\n    options = defaults(options, defaultTransOpts);\n\n    var getCurrent = function () {\n      return globals.transition;\n    };\n\n    options = extend(options, {\n      current: getCurrent\n    });\n    var ref = this.target(to, toParams, options);\n    var currentPath = this.getCurrentPath();\n    if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);\n    if (!ref.valid()) return silentRejection(ref.error());\n\n    if (options.supercede === false && getCurrent()) {\n      return Rejection.ignored('Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.').toPromise();\n    }\n    /**\n     * Special handling for Ignored, Aborted, and Redirected transitions\n     *\n     * The semantics for the transition.run() promise and the StateService.transitionTo()\n     * promise differ. For instance, the run() promise may be rejected because it was\n     * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n     * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n     * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n     */\n\n\n    var rejectedTransitionHandler = function (trans) {\n      return function (error) {\n        if (error instanceof Rejection) {\n          var isLatest = router.globals.lastStartedTransitionId <= trans.$id;\n\n          if (error.type === RejectType.IGNORED) {\n            isLatest && router.urlRouter.update(); // Consider ignored `Transition.run()` as a successful `transitionTo`\n\n            return services.$q.when(globals.current);\n          }\n\n          var detail = error.detail;\n\n          if (error.type === RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {\n            // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n            // by returning the promise for the new (redirect) `Transition.run()`.\n            var redirect = trans.redirect(detail);\n            return redirect.run().catch(rejectedTransitionHandler(redirect));\n          }\n\n          if (error.type === RejectType.ABORTED) {\n            isLatest && router.urlRouter.update();\n            return services.$q.reject(error);\n          }\n        }\n\n        var errorHandler = _this.defaultErrorHandler();\n\n        errorHandler(error);\n        return services.$q.reject(error);\n      };\n    };\n\n    var transition = this.router.transitionService.create(currentPath, ref);\n    var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n    silenceUncaughtInPromise(transitionToPromise); // issue #2676\n    // Return a promise for the transition, which also has the transition object on it.\n\n    return extend(transitionToPromise, {\n      transition: transition\n    });\n  };\n  /**\n   * Checks if the current state *is* the provided state\n   *\n   * Similar to [[includes]] but only checks for the full state name.\n   * If params is supplied then it will be tested for strict equality against the current\n   * active params object, so all params must match with none missing and no extras.\n   *\n   * #### Example:\n   * ```js\n   * $state.$current.name = 'contacts.details.item';\n   *\n   * // absolute name\n   * $state.is('contact.details.item'); // returns true\n   * $state.is(contactDetailItemStateObject); // returns true\n   * ```\n   *\n   * // relative name (. and ^), typically from a template\n   * // E.g. from the 'contacts.details' template\n   * ```html\n   * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n   * ```\n   *\n   * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n   * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n   * to test against the current active state.\n   * @param options An options object. The options are:\n   *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n   *     test relative to `options.relative` state (or name).\n   *\n   * @returns Returns true if it is the state.\n   */\n\n\n  StateService.prototype.is = function (stateOrName, params, options) {\n    options = defaults(options, {\n      relative: this.$current\n    });\n    var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n    if (!isDefined(state)) return undefined;\n    if (this.$current !== state) return false;\n    if (!params) return true;\n    var schema = state.parameters({\n      inherit: true,\n      matchingKeys: params\n    });\n    return Param.equals(schema, Param.values(schema, params), this.params);\n  };\n  /**\n   * Checks if the current state *includes* the provided state\n   *\n   * A method to determine if the current active state is equal to or is the child of the\n   * state stateName. If any params are passed then they will be tested for a match as well.\n   * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n   *\n   * #### Example when `$state.$current.name === 'contacts.details.item'`\n   * ```js\n   * // Using partial names\n   * $state.includes(\"contacts\"); // returns true\n   * $state.includes(\"contacts.details\"); // returns true\n   * $state.includes(\"contacts.details.item\"); // returns true\n   * $state.includes(\"contacts.list\"); // returns false\n   * $state.includes(\"about\"); // returns false\n   * ```\n   *\n   * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n   * ```js\n   * $state.includes(\"*.details.*.*\"); // returns true\n   * $state.includes(\"*.details.**\"); // returns true\n   * $state.includes(\"**.item.**\"); // returns true\n   * $state.includes(\"*.details.item.url\"); // returns true\n   * $state.includes(\"*.details.*.url\"); // returns true\n   * $state.includes(\"*.details.*\"); // returns false\n   * $state.includes(\"item.**\"); // returns false\n   * ```\n   *\n   * @param stateOrName A partial name, relative name, glob pattern,\n   *   or state object to be searched for within the current state name.\n   * @param params A param object, e.g. `{sectionId: section.id}`,\n   *   that you'd like to test against the current active state.\n   * @param options An options object. The options are:\n   *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n   *     test relative to `options.relative` state (or name).\n   *\n   * @returns {boolean} Returns true if it does include the state\n   */\n\n\n  StateService.prototype.includes = function (stateOrName, params, options) {\n    options = defaults(options, {\n      relative: this.$current\n    });\n    var glob = isString(stateOrName) && Glob.fromString(stateOrName);\n\n    if (glob) {\n      if (!glob.matches(this.$current.name)) return false;\n      stateOrName = this.$current.name;\n    }\n\n    var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative),\n        include = this.$current.includes;\n    if (!isDefined(state)) return undefined;\n    if (!isDefined(include[state.name])) return false;\n    if (!params) return true;\n    var schema = state.parameters({\n      inherit: true,\n      matchingKeys: params\n    });\n    return Param.equals(schema, Param.values(schema, params), this.params);\n  };\n  /**\n   * Generates a URL for a state and parameters\n   *\n   * Returns the url for the given state populated with the given params.\n   *\n   * #### Example:\n   * ```js\n   * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n   * ```\n   *\n   * @param stateOrName The state name or state object you'd like to generate a url from.\n   * @param params An object of parameter values to fill the state's required parameters.\n   * @param options Options object. The options are:\n   *\n   * @returns {string} compiled state url\n   */\n\n\n  StateService.prototype.href = function (stateOrName, params, options) {\n    var defaultHrefOpts = {\n      lossy: true,\n      inherit: true,\n      absolute: false,\n      relative: this.$current\n    };\n    options = defaults(options, defaultHrefOpts);\n    params = params || {};\n    var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n    if (!isDefined(state)) return null;\n    if (options.inherit) params = this.params.$inherit(params, this.$current, state);\n    var nav = state && options.lossy ? state.navigable : state;\n\n    if (!nav || nav.url === undefined || nav.url === null) {\n      return null;\n    }\n\n    return this.router.urlRouter.href(nav.url, params, {\n      absolute: options.absolute\n    });\n  };\n  /**\n   * Sets or gets the default [[transitionTo]] error handler.\n   *\n   * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n   * This includes errors caused by resolves and transition hooks.\n   *\n   * Note:\n   * This handler does not receive certain Transition rejections.\n   * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n   *\n   * The built-in default error handler logs the error to the console.\n   *\n   * You can provide your own custom handler.\n   *\n   * #### Example:\n   * ```js\n   * stateService.defaultErrorHandler(function() {\n   *   // Do not log transitionTo errors\n   * });\n   * ```\n   *\n   * @param handler a global error handler function\n   * @returns the current global error handler\n   */\n\n\n  StateService.prototype.defaultErrorHandler = function (handler) {\n    return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n  };\n\n  StateService.prototype.get = function (stateOrName, base) {\n    var reg = this.router.stateRegistry;\n    if (arguments.length === 0) return reg.get();\n    return reg.get(stateOrName, base || this.$current);\n  };\n  /**\n   * Lazy loads a state\n   *\n   * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n   *\n   * @param stateOrName the state that should be lazy loaded\n   * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n   * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n   * This noop transition is not actually run.\n   *\n   * @returns a promise to lazy load\n   */\n\n\n  StateService.prototype.lazyLoad = function (stateOrName, transition) {\n    var state = this.get(stateOrName);\n    if (!state || !state.lazyLoad) throw new Error('Can not lazy load ' + stateOrName);\n    var currentPath = this.getCurrentPath();\n    var target = PathUtils.makeTargetState(this.router.stateRegistry, currentPath);\n    transition = transition || this.router.transitionService.create(currentPath, target);\n    return lazyLoadState(transition, state);\n  };\n\n  return StateService;\n}();\n\nexport { StateService };","map":{"version":3,"sources":["@uirouter/core/state/stateService.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module state */\nimport {\n  createProxyFunctions,\n  defaults,\n  extend,\n  inArray,\n  noop,\n  removeFrom,\n  silenceUncaughtInPromise,\n  silentRejection,\n} from '../common/common';\nimport { isDefined, isObject, isString } from '../common/predicates';\nimport { Queue } from '../common/queue';\nimport { services } from '../common/coreservices';\n\nimport { PathUtils } from '../path/pathUtils';\nimport { PathNode } from '../path/pathNode';\n\nimport { HookResult, TransitionOptions } from '../transition/interface';\nimport { defaultTransOpts } from '../transition/transitionService';\nimport { Rejection, RejectType } from '../transition/rejectFactory';\nimport { Transition } from '../transition/transition';\n\nimport { HrefOptions, LazyLoadResult, StateDeclaration, StateOrName, TransitionPromise } from './interface';\nimport { StateObject } from './stateObject';\nimport { TargetState } from './targetState';\n\nimport { RawParams } from '../params/interface';\nimport { Param } from '../params/param';\nimport { Glob } from '../common/glob';\nimport { UIRouter } from '../router';\nimport { UIInjector } from '../interface';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { lazyLoadState } from '../hooks/lazyLoad';\nimport { not, val } from '../common/hof';\nimport { StateParams } from '../params/stateParams';\n\nexport type OnInvalidCallback = (toState?: TargetState, fromState?: TargetState, injector?: UIInjector) => HookResult;\n\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nexport class StateService {\n  /** @internalapi */\n  invalidCallbacks: OnInvalidCallback[] = [];\n\n  /**\n   * The [[Transition]] currently in progress (or null)\n   *\n   * This is a passthrough through to [[UIRouterGlobals.transition]]\n   */\n  get transition() {\n    return this.router.globals.transition;\n  }\n  /**\n   * The latest successful state parameters\n   *\n   * This is a passthrough through to [[UIRouterGlobals.params]]\n   */\n  get params(): StateParams {\n    return this.router.globals.params;\n  }\n  /**\n   * The current [[StateDeclaration]]\n   *\n   * This is a passthrough through to [[UIRouterGlobals.current]]\n   */\n  get current() {\n    return this.router.globals.current;\n  }\n  /**\n   * The current [[StateObject]]\n   *\n   * This is a passthrough through to [[UIRouterGlobals.$current]]\n   */\n  get $current() {\n    return this.router.globals.$current;\n  }\n\n  /** @internalapi */\n  constructor(/** @hidden */ private router: UIRouter) {\n    const getters = ['current', '$current', 'params', 'transition'];\n    const boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));\n    createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);\n  }\n\n  /** @internalapi */\n  dispose() {\n    this.defaultErrorHandler(noop);\n    this.invalidCallbacks = [];\n  }\n\n  /**\n   * Handler for when [[transitionTo]] is called with an invalid state.\n   *\n   * Invokes the [[onInvalid]] callbacks, in natural order.\n   * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n   * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n   *\n   * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n   *\n   * @internalapi\n   */\n  private _handleInvalidTargetState(fromPath: PathNode[], toState: TargetState) {\n    const fromState = PathUtils.makeTargetState(this.router.stateRegistry, fromPath);\n    const globals = this.router.globals;\n    const latestThing = () => globals.transitionHistory.peekTail();\n    const latest = latestThing();\n    const callbackQueue = new Queue<OnInvalidCallback>(this.invalidCallbacks.slice());\n    const injector = new ResolveContext(fromPath).injector();\n\n    const checkForRedirect = (result: HookResult) => {\n      if (!(result instanceof TargetState)) {\n        return;\n      }\n\n      let target = <TargetState>result;\n      // Recreate the TargetState, in case the state is now defined.\n      target = this.target(target.identifier(), target.params(), target.options());\n\n      if (!target.valid()) {\n        return Rejection.invalid(target.error()).toPromise();\n      }\n\n      if (latestThing() !== latest) {\n        return Rejection.superseded().toPromise();\n      }\n\n      return this.transitionTo(target.identifier(), target.params(), target.options());\n    };\n\n    function invokeNextCallback() {\n      const nextCallback = callbackQueue.dequeue();\n      if (nextCallback === undefined) return Rejection.invalid(toState.error()).toPromise();\n\n      const callbackResult = services.$q.when(nextCallback(toState, fromState, injector));\n      return callbackResult.then(checkForRedirect).then(result => result || invokeNextCallback());\n    }\n\n    return invokeNextCallback();\n  }\n\n  /**\n   * Registers an Invalid State handler\n   *\n   * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n   * has been called with an invalid state reference parameter\n   *\n   * Example:\n   * ```js\n   * stateService.onInvalid(function(to, from, injector) {\n   *   if (to.name() === 'foo') {\n   *     let lazyLoader = injector.get('LazyLoadService');\n   *     return lazyLoader.load('foo')\n   *         .then(() => stateService.target('foo'));\n   *   }\n   * });\n   * ```\n   *\n   * @param {function} callback invoked when the toState is invalid\n   *   This function receives the (invalid) toState, the fromState, and an injector.\n   *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n   *   If one is returned, it is treated as a redirect.\n   *\n   * @returns a function which deregisters the callback\n   */\n  onInvalid(callback: OnInvalidCallback): Function {\n    this.invalidCallbacks.push(callback);\n    return function deregisterListener() {\n      removeFrom(this.invalidCallbacks)(callback);\n    }.bind(this);\n  }\n\n  /**\n   * Reloads the current state\n   *\n   * A method that force reloads the current state, or a partial state hierarchy.\n   * All resolves are re-resolved, and components reinstantiated.\n   *\n   * #### Example:\n   * ```js\n   * let app angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.reload = function(){\n   *     $state.reload();\n   *   }\n   * });\n   * ```\n   *\n   * Note: `reload()` is just an alias for:\n   *\n   * ```js\n   * $state.transitionTo($state.current, $state.params, {\n   *   reload: true, inherit: false\n   * });\n   * ```\n   *\n   * @param reloadState A state name or a state object.\n   *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n   *\n   * #### Example:\n   * ```js\n   * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n   * //and current state is 'contacts.detail.item'\n   * let app angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.reload = function(){\n   *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n   *     $state.reload('contact.detail');\n   *   }\n   * });\n   * ```\n   *\n   * @returns A promise representing the state of the new transition. See [[StateService.go]]\n   */\n  reload(reloadState?: StateOrName): Promise<StateObject> {\n    return this.transitionTo(this.current, this.params, {\n      reload: isDefined(reloadState) ? reloadState : true,\n      inherit: false,\n      notify: false,\n    });\n  }\n\n  /**\n   * Transition to a different state and/or parameters\n   *\n   * Convenience method for transitioning to a new state.\n   *\n   * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n   * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n   * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n   * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n   * inherit from the current parameter values (because of `inherit: true`).\n   *\n   * #### Example:\n   * ```js\n   * let app = angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.changeState = function () {\n   *     $state.go('contact.detail');\n   *   };\n   * });\n   * ```\n   *\n   * @param to Absolute state name, state object, or relative state path (relative to current state).\n   *\n   * Some examples:\n   *\n   * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n   * - `$state.go('^')` - will go to the parent state\n   * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n   * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n   *\n   * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n   *\n   *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n   *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n   *\n   * @param options Transition options\n   *\n   * @returns {promise} A promise representing the state of the new transition.\n   */\n  go(to: StateOrName, params?: RawParams, options?: TransitionOptions): TransitionPromise {\n    const defautGoOpts = { relative: this.$current, inherit: true };\n    const transOpts = defaults(options, defautGoOpts, defaultTransOpts);\n    return this.transitionTo(to, params, transOpts);\n  }\n\n  /**\n   * Creates a [[TargetState]]\n   *\n   * This is a factory method for creating a TargetState\n   *\n   * This may be returned from a Transition Hook to redirect a transition, for example.\n   */\n  target(identifier: StateOrName, params?: RawParams, options: TransitionOptions = {}): TargetState {\n    // If we're reloading, find the state object to reload from\n    if (isObject(options.reload) && !(<any>options.reload).name) throw new Error('Invalid reload state object');\n    const reg = this.router.stateRegistry;\n    options.reloadState =\n      options.reload === true ? reg.root() : reg.matcher.find(<any>options.reload, options.relative);\n\n    if (options.reload && !options.reloadState)\n      throw new Error(\n        `No such reload state '${isString(options.reload) ? options.reload : (<any>options.reload).name}'`\n      );\n\n    return new TargetState(this.router.stateRegistry, identifier, params, options);\n  }\n\n  private getCurrentPath(): PathNode[] {\n    const globals = this.router.globals;\n    const latestSuccess: Transition = globals.successfulTransitions.peekTail();\n    const rootPath = () => [new PathNode(this.router.stateRegistry.root())];\n    return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n  }\n\n  /**\n   * Low-level method for transitioning to a new state.\n   *\n   * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n   *\n   * #### Example:\n   * ```js\n   * let app = angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.changeState = function () {\n   *     $state.transitionTo('contact.detail');\n   *   };\n   * });\n   * ```\n   *\n   * @param to State name or state object.\n   * @param toParams A map of the parameters that will be sent to the state,\n   *      will populate $stateParams.\n   * @param options Transition options\n   *\n   * @returns A promise representing the state of the new transition. See [[go]]\n   */\n  transitionTo(to: StateOrName, toParams: RawParams = {}, options: TransitionOptions = {}): TransitionPromise {\n    const router = this.router;\n    const globals = router.globals;\n    options = defaults(options, defaultTransOpts);\n    const getCurrent = () => globals.transition;\n    options = extend(options, { current: getCurrent });\n\n    const ref: TargetState = this.target(to, toParams, options);\n    const currentPath = this.getCurrentPath();\n\n    if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);\n\n    if (!ref.valid()) return <TransitionPromise>silentRejection(ref.error());\n\n    if (options.supercede === false && getCurrent()) {\n      return <TransitionPromise>Rejection.ignored('Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.').toPromise();\n    }\n\n    /**\n     * Special handling for Ignored, Aborted, and Redirected transitions\n     *\n     * The semantics for the transition.run() promise and the StateService.transitionTo()\n     * promise differ. For instance, the run() promise may be rejected because it was\n     * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n     * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n     * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n     */\n    const rejectedTransitionHandler = (trans: Transition) => (error: any): Promise<any> => {\n      if (error instanceof Rejection) {\n        const isLatest = router.globals.lastStartedTransitionId <= trans.$id;\n\n        if (error.type === RejectType.IGNORED) {\n          isLatest && router.urlRouter.update();\n          // Consider ignored `Transition.run()` as a successful `transitionTo`\n          return services.$q.when(globals.current);\n        }\n\n        const detail: any = error.detail;\n        if (error.type === RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {\n          // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n          // by returning the promise for the new (redirect) `Transition.run()`.\n          const redirect: Transition = trans.redirect(detail);\n          return redirect.run().catch(rejectedTransitionHandler(redirect));\n        }\n\n        if (error.type === RejectType.ABORTED) {\n          isLatest && router.urlRouter.update();\n          return services.$q.reject(error);\n        }\n      }\n\n      const errorHandler = this.defaultErrorHandler();\n      errorHandler(error);\n\n      return services.$q.reject(error);\n    };\n\n    const transition = this.router.transitionService.create(currentPath, ref);\n    const transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n    silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\n    // Return a promise for the transition, which also has the transition object on it.\n    return extend(transitionToPromise, { transition });\n  }\n\n  /**\n   * Checks if the current state *is* the provided state\n   *\n   * Similar to [[includes]] but only checks for the full state name.\n   * If params is supplied then it will be tested for strict equality against the current\n   * active params object, so all params must match with none missing and no extras.\n   *\n   * #### Example:\n   * ```js\n   * $state.$current.name = 'contacts.details.item';\n   *\n   * // absolute name\n   * $state.is('contact.details.item'); // returns true\n   * $state.is(contactDetailItemStateObject); // returns true\n   * ```\n   *\n   * // relative name (. and ^), typically from a template\n   * // E.g. from the 'contacts.details' template\n   * ```html\n   * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n   * ```\n   *\n   * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n   * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n   * to test against the current active state.\n   * @param options An options object. The options are:\n   *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n   *     test relative to `options.relative` state (or name).\n   *\n   * @returns Returns true if it is the state.\n   */\n  is(stateOrName: StateOrName, params?: RawParams, options?: { relative?: StateOrName }): boolean {\n    options = defaults(options, { relative: this.$current });\n    const state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n    if (!isDefined(state)) return undefined;\n    if (this.$current !== state) return false;\n    if (!params) return true;\n\n    const schema: Param[] = state.parameters({ inherit: true, matchingKeys: params });\n    return Param.equals(schema, Param.values(schema, params), this.params);\n  }\n\n  /**\n   * Checks if the current state *includes* the provided state\n   *\n   * A method to determine if the current active state is equal to or is the child of the\n   * state stateName. If any params are passed then they will be tested for a match as well.\n   * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n   *\n   * #### Example when `$state.$current.name === 'contacts.details.item'`\n   * ```js\n   * // Using partial names\n   * $state.includes(\"contacts\"); // returns true\n   * $state.includes(\"contacts.details\"); // returns true\n   * $state.includes(\"contacts.details.item\"); // returns true\n   * $state.includes(\"contacts.list\"); // returns false\n   * $state.includes(\"about\"); // returns false\n   * ```\n   *\n   * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n   * ```js\n   * $state.includes(\"*.details.*.*\"); // returns true\n   * $state.includes(\"*.details.**\"); // returns true\n   * $state.includes(\"**.item.**\"); // returns true\n   * $state.includes(\"*.details.item.url\"); // returns true\n   * $state.includes(\"*.details.*.url\"); // returns true\n   * $state.includes(\"*.details.*\"); // returns false\n   * $state.includes(\"item.**\"); // returns false\n   * ```\n   *\n   * @param stateOrName A partial name, relative name, glob pattern,\n   *   or state object to be searched for within the current state name.\n   * @param params A param object, e.g. `{sectionId: section.id}`,\n   *   that you'd like to test against the current active state.\n   * @param options An options object. The options are:\n   *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n   *     test relative to `options.relative` state (or name).\n   *\n   * @returns {boolean} Returns true if it does include the state\n   */\n  includes(stateOrName: StateOrName, params?: RawParams, options?: TransitionOptions): boolean {\n    options = defaults(options, { relative: this.$current });\n    const glob = isString(stateOrName) && Glob.fromString(<string>stateOrName);\n\n    if (glob) {\n      if (!glob.matches(this.$current.name)) return false;\n      stateOrName = this.$current.name;\n    }\n    const state = this.router.stateRegistry.matcher.find(stateOrName, options.relative),\n      include = this.$current.includes;\n\n    if (!isDefined(state)) return undefined;\n    if (!isDefined(include[state.name])) return false;\n    if (!params) return true;\n\n    const schema: Param[] = state.parameters({ inherit: true, matchingKeys: params });\n    return Param.equals(schema, Param.values(schema, params), this.params);\n  }\n\n  /**\n   * Generates a URL for a state and parameters\n   *\n   * Returns the url for the given state populated with the given params.\n   *\n   * #### Example:\n   * ```js\n   * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n   * ```\n   *\n   * @param stateOrName The state name or state object you'd like to generate a url from.\n   * @param params An object of parameter values to fill the state's required parameters.\n   * @param options Options object. The options are:\n   *\n   * @returns {string} compiled state url\n   */\n  href(stateOrName: StateOrName, params?: RawParams, options?: HrefOptions): string {\n    const defaultHrefOpts = {\n      lossy: true,\n      inherit: true,\n      absolute: false,\n      relative: this.$current,\n    };\n    options = defaults(options, defaultHrefOpts);\n    params = params || {};\n\n    const state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\n    if (!isDefined(state)) return null;\n    if (options.inherit) params = <any>this.params.$inherit(params, this.$current, state);\n\n    const nav = state && options.lossy ? state.navigable : state;\n\n    if (!nav || nav.url === undefined || nav.url === null) {\n      return null;\n    }\n\n    return this.router.urlRouter.href(nav.url, params, { absolute: options.absolute });\n  }\n\n  /** @hidden */\n  private _defaultErrorHandler: ((_error: any) => void) = function $defaultErrorHandler($error$) {\n    if ($error$ instanceof Error && $error$.stack) {\n      console.error($error$);\n      console.error($error$.stack);\n    } else if ($error$ instanceof Rejection) {\n      console.error($error$.toString());\n      if ($error$.detail && $error$.detail.stack) console.error($error$.detail.stack);\n    } else {\n      console.error($error$);\n    }\n  };\n\n  /**\n   * Sets or gets the default [[transitionTo]] error handler.\n   *\n   * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n   * This includes errors caused by resolves and transition hooks.\n   *\n   * Note:\n   * This handler does not receive certain Transition rejections.\n   * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n   *\n   * The built-in default error handler logs the error to the console.\n   *\n   * You can provide your own custom handler.\n   *\n   * #### Example:\n   * ```js\n   * stateService.defaultErrorHandler(function() {\n   *   // Do not log transitionTo errors\n   * });\n   * ```\n   *\n   * @param handler a global error handler function\n   * @returns the current global error handler\n   */\n  defaultErrorHandler(handler?: (error: any) => void): (error: any) => void {\n    return (this._defaultErrorHandler = handler || this._defaultErrorHandler);\n  }\n\n  /**\n   * Gets a registered [[StateDeclaration]] object\n   *\n   * Returns the state declaration object for any specific state, or for all registered states.\n   *\n   * @param stateOrName (absolute or relative) If provided, will only get the declaration object for the requested state.\n   * If not provided, returns an array of ALL states.\n   * @param base When `stateOrName` is a relative state reference (such as `.bar.baz`), the state will be retrieved relative to this state.\n   *\n   * @returns a [[StateDeclaration]] object (or array of all registered [[StateDeclaration]] objects.)\n   */\n  get(stateOrName: StateOrName, base: StateOrName): StateDeclaration;\n  get(stateOrName: StateOrName): StateDeclaration;\n  get(): StateDeclaration[];\n  get(stateOrName?: StateOrName, base?: StateOrName): any {\n    const reg = this.router.stateRegistry;\n    if (arguments.length === 0) return reg.get();\n    return reg.get(stateOrName, base || this.$current);\n  }\n\n  /**\n   * Lazy loads a state\n   *\n   * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n   *\n   * @param stateOrName the state that should be lazy loaded\n   * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n   * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n   * This noop transition is not actually run.\n   *\n   * @returns a promise to lazy load\n   */\n  lazyLoad(stateOrName: StateOrName, transition?: Transition): Promise<LazyLoadResult> {\n    const state: StateDeclaration = this.get(stateOrName);\n    if (!state || !state.lazyLoad) throw new Error('Can not lazy load ' + stateOrName);\n\n    const currentPath = this.getCurrentPath();\n    const target = PathUtils.makeTargetState(this.router.stateRegistry, currentPath);\n    transition = transition || this.router.transitionService.create(currentPath, target);\n\n    return lazyLoadState(transition, state);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}