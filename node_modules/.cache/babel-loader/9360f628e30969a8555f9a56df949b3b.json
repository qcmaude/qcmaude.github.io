{"ast":null,"code":"/** @packageDocumentation @publicapi @module transition */\nimport { TransitionHookPhase } from './interface';\nimport { defaults, noop, silentRejection } from '../common/common';\nimport { fnToString, maxLength } from '../common/strings';\nimport { isPromise } from '../common/predicates';\nimport { is, parse } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { Rejection } from './rejectFactory';\nimport { TargetState } from '../state/targetState';\nvar defaultOptions = {\n  current: noop,\n  transition: null,\n  traceData: {},\n  bind: null\n};\n/** @hidden */\n\nvar TransitionHook =\n/** @class */\nfunction () {\n  function TransitionHook(transition, stateContext, registeredHook, options) {\n    var _this = this;\n\n    this.transition = transition;\n    this.stateContext = stateContext;\n    this.registeredHook = registeredHook;\n    this.options = options;\n\n    this.isSuperseded = function () {\n      return _this.type.hookPhase === TransitionHookPhase.RUN && !_this.options.transition.isActive();\n    };\n\n    this.options = defaults(options, defaultOptions);\n    this.type = registeredHook.eventType;\n  }\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param hooks the list of hooks to chain together\n   * @param waitFor if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n\n\n  TransitionHook.chain = function (hooks, waitFor) {\n    // Chain the next hook off the previous\n    var createHookChainR = function (prev, nextHook) {\n      return prev.then(function () {\n        return nextHook.invokeHook();\n      });\n    };\n\n    return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n  };\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param hooks the list of TransitionHooks to invoke\n   * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns a promise for the async result, or the result of the callback\n   */\n\n\n  TransitionHook.invokeHooks = function (hooks, doneCallback) {\n    for (var idx = 0; idx < hooks.length; idx++) {\n      var hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        var remainingHooks = hooks.slice(idx + 1);\n        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);\n      }\n    }\n\n    return doneCallback();\n  };\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   */\n\n\n  TransitionHook.runAllHooks = function (hooks) {\n    hooks.forEach(function (hook) {\n      return hook.invokeHook();\n    });\n  };\n\n  TransitionHook.prototype.logError = function (err) {\n    this.transition.router.stateService.defaultErrorHandler()(err);\n  };\n\n  TransitionHook.prototype.invokeHook = function () {\n    var _this = this;\n\n    var hook = this.registeredHook;\n    if (hook._deregistered) return;\n    var notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n    var options = this.options;\n    trace.traceHookInvocation(this, this.transition, options);\n\n    var invokeCallback = function () {\n      return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n    };\n\n    var normalizeErr = function (err) {\n      return Rejection.normalize(err).toPromise();\n    };\n\n    var handleError = function (err) {\n      return hook.eventType.getErrorHandler(_this)(err);\n    };\n\n    var handleResult = function (result) {\n      return hook.eventType.getResultHandler(_this)(result);\n    };\n\n    try {\n      var result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return result.catch(normalizeErr).then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  };\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   */\n\n\n  TransitionHook.prototype.handleHookResult = function (result) {\n    var _this = this;\n\n    var notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent; // Hook returned a promise\n\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return result.then(function (val) {\n        return _this.handleHookResult(val);\n      });\n    }\n\n    trace.traceHookResult(result, this.transition, this.options); // Hook returned false\n\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted('Hook aborted transition').toPromise();\n    }\n\n    var isTargetState = is(TargetState); // hook returned a TargetState\n\n    if (isTargetState(result)) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n  };\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * to a stopped router (disposed), or a new transition has started and superseded this one.\n   */\n\n\n  TransitionHook.prototype.getNotCurrentRejection = function () {\n    var router = this.transition.router; // The router is stopped\n\n    if (router._disposed) {\n      return Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n    }\n\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    } // This transition is no longer current.\n    // Another transition started while this hook was still running.\n\n\n    if (this.isSuperseded()) {\n      // Abort this transition\n      return Rejection.superseded(this.options.current()).toPromise();\n    }\n  };\n\n  TransitionHook.prototype.toString = function () {\n    var _a = this,\n        options = _a.options,\n        registeredHook = _a.registeredHook;\n\n    var event = parse('traceData.hookType')(options) || 'internal',\n        context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown',\n        name = fnToString(registeredHook.callback);\n    return event + \" context: \" + context + \", \" + maxLength(200, name);\n  };\n  /**\n   * These GetResultHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n\n\n  TransitionHook.HANDLE_RESULT = function (hook) {\n    return function (result) {\n      return hook.handleHookResult(result);\n    };\n  };\n  /**\n   * If the result is a promise rejection, log it.\n   * Otherwise, ignore the result.\n   */\n\n\n  TransitionHook.LOG_REJECTED_RESULT = function (hook) {\n    return function (result) {\n      isPromise(result) && result.catch(function (err) {\n        return hook.logError(Rejection.normalize(err));\n      });\n      return undefined;\n    };\n  };\n  /**\n   * These GetErrorHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n\n\n  TransitionHook.LOG_ERROR = function (hook) {\n    return function (error) {\n      return hook.logError(error);\n    };\n  };\n\n  TransitionHook.REJECT_ERROR = function (hook) {\n    return function (error) {\n      return silentRejection(error);\n    };\n  };\n\n  TransitionHook.THROW_ERROR = function (hook) {\n    return function (error) {\n      throw error;\n    };\n  };\n\n  return TransitionHook;\n}();\n\nexport { TransitionHook };","map":{"version":3,"sources":["@uirouter/core/transition/transitionHook.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module transition */\nimport { TransitionHookOptions, HookResult, TransitionHookPhase } from './interface';\nimport { defaults, noop, silentRejection } from '../common/common';\nimport { fnToString, maxLength } from '../common/strings';\nimport { isPromise } from '../common/predicates';\nimport { is, parse } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { Rejection } from './rejectFactory';\nimport { TargetState } from '../state/targetState';\nimport { Transition } from './transition';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\nimport { StateDeclaration } from '../state/interface';\n\nconst defaultOptions: TransitionHookOptions = {\n  current: noop,\n  transition: null,\n  traceData: {},\n  bind: null,\n};\n\nexport type GetResultHandler = (hook: TransitionHook) => ResultHandler;\nexport type GetErrorHandler = (hook: TransitionHook) => ErrorHandler;\n\nexport type ResultHandler = (result: HookResult) => Promise<HookResult>;\nexport type ErrorHandler = (error: any) => Promise<any>;\n\n/** @hidden */\nexport class TransitionHook {\n  type: TransitionEventType;\n\n  /**\n   * These GetResultHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static HANDLE_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) =>\n    hook.handleHookResult(result);\n\n  /**\n   * If the result is a promise rejection, log it.\n   * Otherwise, ignore the result.\n   */\n  static LOG_REJECTED_RESULT: GetResultHandler = (hook: TransitionHook) => (result: HookResult) => {\n    isPromise(result) && result.catch(err => hook.logError(Rejection.normalize(err)));\n    return undefined;\n  };\n\n  /**\n   * These GetErrorHandler(s) are used by [[invokeHook]] below\n   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n   */\n  static LOG_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => hook.logError(error);\n\n  static REJECT_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => silentRejection(error);\n\n  static THROW_ERROR: GetErrorHandler = (hook: TransitionHook) => (error: any) => {\n    throw error;\n  };\n\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param hooks the list of hooks to chain together\n   * @param waitFor if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n  static chain(hooks: TransitionHook[], waitFor?: Promise<any>): Promise<any> {\n    // Chain the next hook off the previous\n    const createHookChainR = (prev: Promise<any>, nextHook: TransitionHook) => prev.then(() => nextHook.invokeHook());\n    return hooks.reduce(createHookChainR, waitFor || services.$q.when());\n  }\n\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param hooks the list of TransitionHooks to invoke\n   * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns a promise for the async result, or the result of the callback\n   */\n  static invokeHooks<T>(hooks: TransitionHook[], doneCallback: (result?: HookResult) => T): Promise<any> | T {\n    for (let idx = 0; idx < hooks.length; idx++) {\n      const hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        const remainingHooks = hooks.slice(idx + 1);\n\n        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);\n      }\n    }\n\n    return doneCallback();\n  }\n\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   */\n  static runAllHooks(hooks: TransitionHook[]): void {\n    hooks.forEach(hook => hook.invokeHook());\n  }\n\n  constructor(\n    private transition: Transition,\n    private stateContext: StateDeclaration,\n    private registeredHook: RegisteredHook,\n    private options: TransitionHookOptions\n  ) {\n    this.options = defaults(options, defaultOptions);\n    this.type = registeredHook.eventType;\n  }\n\n  private isSuperseded = () => this.type.hookPhase === TransitionHookPhase.RUN && !this.options.transition.isActive();\n\n  logError(err): any {\n    this.transition.router.stateService.defaultErrorHandler()(err);\n  }\n\n  invokeHook(): Promise<HookResult> | void {\n    const hook = this.registeredHook;\n    if (hook._deregistered) return;\n\n    const notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    const options = this.options;\n    trace.traceHookInvocation(this, this.transition, options);\n\n    const invokeCallback = () => hook.callback.call(options.bind, this.transition, this.stateContext);\n\n    const normalizeErr = err => Rejection.normalize(err).toPromise();\n\n    const handleError = err => hook.eventType.getErrorHandler(this)(err);\n\n    const handleResult = result => hook.eventType.getResultHandler(this)(result);\n\n    try {\n      const result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return result.catch(normalizeErr).then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  }\n\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   */\n  handleHookResult(result: HookResult): Promise<HookResult> {\n    const notCurrent = this.getNotCurrentRejection();\n    if (notCurrent) return notCurrent;\n\n    // Hook returned a promise\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return result.then(val => this.handleHookResult(val));\n    }\n\n    trace.traceHookResult(result, this.transition, this.options);\n\n    // Hook returned false\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted('Hook aborted transition').toPromise();\n    }\n\n    const isTargetState = is(TargetState);\n    // hook returned a TargetState\n    if (isTargetState(result)) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n  }\n\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * to a stopped router (disposed), or a new transition has started and superseded this one.\n   */\n  private getNotCurrentRejection() {\n    const router = this.transition.router;\n\n    // The router is stopped\n    if (router._disposed) {\n      return Rejection.aborted(`UIRouter instance #${router.$id} has been stopped (disposed)`).toPromise();\n    }\n\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    }\n\n    // This transition is no longer current.\n    // Another transition started while this hook was still running.\n    if (this.isSuperseded()) {\n      // Abort this transition\n      return Rejection.superseded(this.options.current()).toPromise();\n    }\n  }\n\n  toString() {\n    const { options, registeredHook } = this;\n    const event = parse('traceData.hookType')(options) || 'internal',\n      context = parse('traceData.context.state.name')(options) || parse('traceData.context')(options) || 'unknown',\n      name = fnToString(registeredHook.callback);\n    return `${event} context: ${context}, ${maxLength(200, name)}`;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}