{"ast":null,"code":"/** @packageDocumentation @publicapi @module resolve */\nimport { extend, identity } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { trace } from '../common/trace';\nimport { stringify } from '../common/strings';\nimport { isFunction, isObject } from '../common/predicates';\nimport { isNullOrUndefined } from '../common/predicates'; // TODO: explicitly make this user configurable\n\nexport var defaultResolvePolicy = {\n  when: 'LAZY',\n  async: 'WAIT'\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\n\nvar Resolvable =\n/** @class */\nfunction () {\n  function Resolvable(arg1, resolveFn, deps, policy, data) {\n    this.resolved = false;\n    this.promise = undefined;\n\n    if (arg1 instanceof Resolvable) {\n      extend(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      if (isNullOrUndefined(arg1)) throw new Error('new Resolvable(): token argument is required');\n      if (!isFunction(resolveFn)) throw new Error('new Resolvable(): resolveFn argument must be a function');\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n    } else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {\n      var literal = arg1;\n      return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n    }\n  }\n\n  Resolvable.prototype.getPolicy = function (state) {\n    var thisPolicy = this.policy || {};\n    var statePolicy = state && state.resolvePolicy || {};\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async\n    };\n  };\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   */\n\n\n  Resolvable.prototype.resolve = function (resolveContext, trans) {\n    var _this = this;\n\n    var $q = services.$q; // Gets all dependencies from ResolveContext and wait for them to be resolved\n\n    var getResolvableDependencies = function () {\n      return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n        return resolvable.get(resolveContext, trans);\n      }));\n    }; // Invokes the resolve function passing the resolved dependencies as arguments\n\n\n    var invokeResolveFn = function (resolvedDeps) {\n      return _this.resolveFn.apply(null, resolvedDeps);\n    };\n\n    var node = resolveContext.findNode(this);\n    var state = node && node.state;\n    var asyncPolicy = this.getPolicy(state).async;\n    var customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity; // After the final value has been resolved, update the state of the Resolvable\n\n    var applyResolvedValue = function (resolvedValue) {\n      _this.data = resolvedValue;\n      _this.resolved = true;\n      _this.resolveFn = null;\n      trace.traceResolvableResolved(_this, trans);\n      return _this.data;\n    }; // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\n\n    return this.promise = $q.when().then(getResolvableDependencies).then(invokeResolveFn).then(customAsyncPolicy).then(applyResolvedValue);\n  };\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   */\n\n\n  Resolvable.prototype.get = function (resolveContext, trans) {\n    return this.promise || this.resolve(resolveContext, trans);\n  };\n\n  Resolvable.prototype.toString = function () {\n    return \"Resolvable(token: \" + stringify(this.token) + \", requires: [\" + this.deps.map(stringify) + \"])\";\n  };\n\n  Resolvable.prototype.clone = function () {\n    return new Resolvable(this);\n  };\n\n  Resolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () {\n      return data;\n    }, null, null, data);\n  };\n\n  return Resolvable;\n}();\n\nexport { Resolvable };","map":{"version":3,"sources":["@uirouter/core/resolve/resolvable.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module resolve */\nimport { extend, identity } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { trace } from '../common/trace';\nimport { ResolvePolicy, ResolvableLiteral, PolicyAsync } from './interface';\n\nimport { ResolveContext } from './resolveContext';\nimport { stringify } from '../common/strings';\nimport { isFunction, isObject } from '../common/predicates';\nimport { Transition } from '../transition/transition';\nimport { StateObject } from '../state/stateObject';\nimport { PathNode } from '../path/pathNode';\nimport { isNullOrUndefined } from '../common/predicates';\n\n// TODO: explicitly make this user configurable\nexport let defaultResolvePolicy: ResolvePolicy = {\n  when: 'LAZY',\n  async: 'WAIT',\n};\n\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nexport class Resolvable implements ResolvableLiteral {\n  token: any;\n  policy: ResolvePolicy;\n  resolveFn: Function;\n  deps: any[];\n\n  data: any;\n  resolved = false;\n  promise: Promise<any> = undefined;\n\n  static fromData = (token: any, data: any) => new Resolvable(token, () => data, null, null, data);\n\n  /** This constructor creates a Resolvable copy */\n  constructor(resolvable: Resolvable);\n\n  /** This constructor creates a new Resolvable from the plain old [[ResolvableLiteral]] javascript object */\n  constructor(resolvable: ResolvableLiteral);\n\n  /**\n   * This constructor creates a new `Resolvable`\n   *\n   * #### Example:\n   * ```js\n   * var resolvable1 = new Resolvable('mytoken', http => http.get('foo.json').toPromise(), [Http]);\n   *\n   * var resolvable2 = new Resolvable(UserService, dep => new UserService(dep.data), [SomeDependency]);\n   *\n   * var resolvable1Clone = new Resolvable(resolvable1);\n   * ```\n   *\n   * @param token The new resolvable's injection token, such as `\"userList\"` (a string) or `UserService` (a class).\n   *              When this token is used during injection, the resolved value will be injected.\n   * @param resolveFn The function that returns the resolved value, or a promise for the resolved value\n   * @param deps An array of dependencies, which will be injected into the `resolveFn`\n   * @param policy the [[ResolvePolicy]] defines when and how the Resolvable is processed\n   * @param data Pre-resolved data. If the resolve value is already known, it may be provided here.\n   */\n  constructor(token: any, resolveFn: Function, deps?: any[], policy?: ResolvePolicy, data?: any);\n  constructor(arg1: any, resolveFn?: Function, deps?: any[], policy?: ResolvePolicy, data?: any) {\n    if (arg1 instanceof Resolvable) {\n      extend(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      if (isNullOrUndefined(arg1)) throw new Error('new Resolvable(): token argument is required');\n      if (!isFunction(resolveFn)) throw new Error('new Resolvable(): resolveFn argument must be a function');\n\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? services.$q.when(this.data) : undefined;\n    } else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty('resolveFn') || arg1.hasOwnProperty('data'))) {\n      const literal = <ResolvableLiteral>arg1;\n      return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n    }\n  }\n\n  getPolicy(state: StateObject): ResolvePolicy {\n    const thisPolicy = this.policy || {};\n    const statePolicy = (state && state.resolvePolicy) || {};\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n    };\n  }\n\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   */\n  resolve(resolveContext: ResolveContext, trans?: Transition) {\n    const $q = services.$q;\n\n    // Gets all dependencies from ResolveContext and wait for them to be resolved\n    const getResolvableDependencies = () =>\n      $q.all(resolveContext.getDependencies(this).map(resolvable => resolvable.get(resolveContext, trans))) as Promise<\n        any[]\n      >;\n\n    // Invokes the resolve function passing the resolved dependencies as arguments\n    const invokeResolveFn = (resolvedDeps: any[]) => this.resolveFn.apply(null, resolvedDeps);\n    const node: PathNode = resolveContext.findNode(this);\n    const state: StateObject = node && node.state;\n\n    const asyncPolicy: PolicyAsync = this.getPolicy(state).async;\n    const customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : identity;\n\n    // After the final value has been resolved, update the state of the Resolvable\n    const applyResolvedValue = (resolvedValue: any) => {\n      this.data = resolvedValue;\n      this.resolved = true;\n      this.resolveFn = null;\n      trace.traceResolvableResolved(this, trans);\n      return this.data;\n    };\n\n    // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n    return (this.promise = $q\n      .when()\n      .then(getResolvableDependencies)\n      .then(invokeResolveFn)\n      .then(customAsyncPolicy)\n      .then(applyResolvedValue));\n  }\n\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   */\n  get(resolveContext: ResolveContext, trans?: Transition): Promise<any> {\n    return this.promise || this.resolve(resolveContext, trans);\n  }\n\n  toString() {\n    return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;\n  }\n\n  clone(): Resolvable {\n    return new Resolvable(this);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}