{"ast":null,"code":"/** @packageDocumentation @internalapi @module hooks */\nimport { noop } from '../common/common';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { val } from '../common/hof';\nexport var RESOLVE_HOOK_PRIORITY = 1000;\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\n\nvar eagerResolvePath = function (trans) {\n  return new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);\n};\n\nexport var registerEagerResolvePath = function (transitionService) {\n  return transitionService.onStart({}, eagerResolvePath, {\n    priority: RESOLVE_HOOK_PRIORITY\n  });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\n\nvar lazyResolveState = function (trans, state) {\n  return new ResolveContext(trans.treeChanges().to).subContext(state.$$state()).resolvePath('LAZY', trans).then(noop);\n};\n\nexport var registerLazyResolveState = function (transitionService) {\n  return transitionService.onEnter({\n    entering: val(true)\n  }, lazyResolveState, {\n    priority: RESOLVE_HOOK_PRIORITY\n  });\n};\n/**\n * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.\n *\n * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`\n *\n * After all entering states have been entered, this hook resolves any remaining Resolvables.\n * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].\n *\n * See [[StateDeclaration.resolve]]\n */\n\nvar resolveRemaining = function (trans) {\n  return new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);\n};\n\nexport var registerResolveRemaining = function (transitionService) {\n  return transitionService.onFinish({}, resolveRemaining, {\n    priority: RESOLVE_HOOK_PRIORITY\n  });\n};","map":{"version":3,"sources":["@uirouter/core/hooks/resolve.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,IAAT,QAAqB,kBAArB;AAEA,SAAS,cAAT,QAA+B,2BAA/B;AAGA,SAAS,GAAT,QAAoB,eAApB;AAGA,OAAO,IAAM,qBAAqB,GAAG,IAA9B;AAEP;;;;;;;;AAQG;;AACH,IAAM,gBAAgB,GAAqB,UAAC,KAAD,EAAkB;AAC3D,SAAA,IAAI,cAAJ,CAAmB,KAAK,CAAC,WAAN,GAAoB,EAAvC,EAA2C,WAA3C,CAAuD,OAAvD,EAAgE,KAAhE,EAAuE,IAAvE,CAA4E,IAA5E,CAAA;AAAiF,CADnF;;AAGA,OAAO,IAAM,wBAAwB,GAAG,UAAC,iBAAD,EAAqC;AAC3E,SAAA,iBAAiB,CAAC,OAAlB,CAA0B,EAA1B,EAA8B,gBAA9B,EAAgD;AAAE,IAAA,QAAQ,EAAE;AAAZ,GAAhD,CAAA;AAAoF,CAD/E;AAGP;;;;;;;;AAQG;;AACH,IAAM,gBAAgB,GAA0B,UAAC,KAAD,EAAoB,KAApB,EAA2C;AACzF,SAAA,IAAI,cAAJ,CAAmB,KAAK,CAAC,WAAN,GAAoB,EAAvC,EACG,UADH,CACc,KAAK,CAAC,OAAN,EADd,EAEG,WAFH,CAEe,MAFf,EAEuB,KAFvB,EAGG,IAHH,CAGQ,IAHR,CAAA;AAGa,CAJf;;AAMA,OAAO,IAAM,wBAAwB,GAAG,UAAC,iBAAD,EAAqC;AAC3E,SAAA,iBAAiB,CAAC,OAAlB,CAA0B;AAAE,IAAA,QAAQ,EAAE,GAAG,CAAC,IAAD;AAAf,GAA1B,EAAmD,gBAAnD,EAAqE;AAAE,IAAA,QAAQ,EAAE;AAAZ,GAArE,CAAA;AAAyG,CADpG;AAGP;;;;;;;;;AASG;;AACH,IAAM,gBAAgB,GAAqB,UAAC,KAAD,EAAkB;AAC3D,SAAA,IAAI,cAAJ,CAAmB,KAAK,CAAC,WAAN,GAAoB,EAAvC,EAA2C,WAA3C,CAAuD,MAAvD,EAA+D,KAA/D,EAAsE,IAAtE,CAA2E,IAA3E,CAAA;AAAgF,CADlF;;AAGA,OAAO,IAAM,wBAAwB,GAAG,UAAC,iBAAD,EAAqC;AAC3E,SAAA,iBAAiB,CAAC,QAAlB,CAA2B,EAA3B,EAA+B,gBAA/B,EAAiD;AAAE,IAAA,QAAQ,EAAE;AAAZ,GAAjD,CAAA;AAAqF,CADhF","sourcesContent":["/** @packageDocumentation @internalapi @module hooks */\nimport { noop } from '../common/common';\nimport { Transition } from '../transition/transition';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { TransitionStateHookFn, TransitionHookFn } from '../transition/interface';\nimport { TransitionService } from '../transition/transitionService';\nimport { val } from '../common/hof';\nimport { StateDeclaration } from '../state/interface';\n\nexport const RESOLVE_HOOK_PRIORITY = 1000;\n\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nconst eagerResolvePath: TransitionHookFn = (trans: Transition) =>\n  new ResolveContext(trans.treeChanges().to).resolvePath('EAGER', trans).then(noop);\n\nexport const registerEagerResolvePath = (transitionService: TransitionService) =>\n  transitionService.onStart({}, eagerResolvePath, { priority: RESOLVE_HOOK_PRIORITY });\n\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nconst lazyResolveState: TransitionStateHookFn = (trans: Transition, state: StateDeclaration) =>\n  new ResolveContext(trans.treeChanges().to)\n    .subContext(state.$$state())\n    .resolvePath('LAZY', trans)\n    .then(noop);\n\nexport const registerLazyResolveState = (transitionService: TransitionService) =>\n  transitionService.onEnter({ entering: val(true) }, lazyResolveState, { priority: RESOLVE_HOOK_PRIORITY });\n\n/**\n * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.\n *\n * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`\n *\n * After all entering states have been entered, this hook resolves any remaining Resolvables.\n * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].\n *\n * See [[StateDeclaration.resolve]]\n */\nconst resolveRemaining: TransitionHookFn = (trans: Transition) =>\n  new ResolveContext(trans.treeChanges().to).resolvePath('LAZY', trans).then(noop);\n\nexport const registerResolveRemaining = (transitionService: TransitionService) =>\n  transitionService.onFinish({}, resolveRemaining, { priority: RESOLVE_HOOK_PRIORITY });\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}