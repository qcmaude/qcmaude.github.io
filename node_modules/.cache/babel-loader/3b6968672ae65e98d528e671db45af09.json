{"ast":null,"code":"/** @packageDocumentation @publicapi @module params */\nimport { extend, filter, map, allTrueR, find } from '../common/common';\nimport { prop } from '../common/hof';\nimport { isInjectable, isDefined, isString, isArray, isUndefined } from '../common/predicates';\nimport { services } from '../common/coreservices';\nimport { ParamType } from './paramType';\n/** @hidden */\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */\n\nvar isShorthand = function (cfg) {\n  return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\n\n\nvar DefType;\n\n(function (DefType) {\n  DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n  DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n  DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType || (DefType = {}));\n\nexport { DefType };\n/** @internalapi */\n\nfunction getParamDeclaration(paramName, location, state) {\n  var noReloadOnSearch = state.reloadOnSearch === false && location === DefType.SEARCH || undefined;\n  var dynamic = find([state.dynamic, noReloadOnSearch], isDefined);\n  var defaultConfig = isDefined(dynamic) ? {\n    dynamic: dynamic\n  } : {};\n  var paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);\n  return extend(defaultConfig, paramConfig);\n}\n/** @hidden */\n\n\nfunction unwrapShorthand(cfg) {\n  cfg = isShorthand(cfg) ? {\n    value: cfg\n  } : cfg;\n  getStaticDefaultValue['__cacheable'] = true;\n\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n\n  var $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;\n  return extend(cfg, {\n    $$fn: $$fn\n  });\n}\n/** @hidden */\n\n\nfunction getType(cfg, urlType, location, id, paramTypes) {\n  if (cfg.type && urlType && urlType.name !== 'string') throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n  if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type)) return paramTypes.type(cfg.type);\n  if (urlType) return urlType;\n\n  if (!cfg.type) {\n    var type = location === DefType.CONFIG ? 'any' : location === DefType.PATH ? 'path' : location === DefType.SEARCH ? 'query' : 'string';\n    return paramTypes.type(type);\n  }\n\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\n\n\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n  var squash = config.squash;\n  if (!isOptional || squash === false) return false;\n  if (!isDefined(squash) || squash == null) return defaultPolicy;\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n/** @internalapi */\n\n\nfunction getReplace(config, arrayMode, isOptional, squash) {\n  var defaultPolicy = [{\n    from: '',\n    to: isOptional || arrayMode ? undefined : ''\n  }, {\n    from: null,\n    to: isOptional || arrayMode ? undefined : ''\n  }];\n  var replace = isArray(config.replace) ? config.replace : [];\n  if (isString(squash)) replace.push({\n    from: squash,\n    to: undefined\n  });\n  var configuredKeys = map(replace, prop('from'));\n  return filter(defaultPolicy, function (item) {\n    return configuredKeys.indexOf(item.from) === -1;\n  }).concat(replace);\n}\n/** @internalapi */\n\n\nvar Param =\n/** @class */\nfunction () {\n  function Param(id, type, location, urlConfig, state) {\n    var config = getParamDeclaration(id, location, state);\n    type = getType(config, type, location, id, urlConfig.paramTypes);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n    var isOptional = config.value !== undefined || location === DefType.SEARCH;\n    var dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n    var raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n    var squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n    var inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit; // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\n    function getArrayMode() {\n      var arrayDefaults = {\n        array: location === DefType.SEARCH ? 'auto' : false\n      };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? {\n        array: true\n      } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      isOptional: isOptional,\n      dynamic: dynamic,\n      raw: raw,\n      squash: squash,\n      replace: replace,\n      inherit: inherit,\n      array: arrayMode,\n      config: config\n    });\n  }\n\n  Param.values = function (params, values) {\n    if (values === void 0) {\n      values = {};\n    }\n\n    var paramValues = {};\n\n    for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n      var param = params_1[_i];\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n\n    return paramValues;\n  };\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   *\n   * @param params: The list of Param objects to filter\n   * @param values1: The first set of parameter values\n   * @param values2: the second set of parameter values\n   *\n   * @returns any Param objects whose values were different between values1 and values2\n   */\n\n\n  Param.changed = function (params, values1, values2) {\n    if (values1 === void 0) {\n      values1 = {};\n    }\n\n    if (values2 === void 0) {\n      values2 = {};\n    }\n\n    return params.filter(function (param) {\n      return !param.type.equals(values1[param.id], values2[param.id]);\n    });\n  };\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   *\n   * @param params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   *\n   * @returns true if the param values in values1 and values2 are equal\n   */\n\n\n  Param.equals = function (params, values1, values2) {\n    if (values1 === void 0) {\n      values1 = {};\n    }\n\n    if (values2 === void 0) {\n      values2 = {};\n    }\n\n    return Param.changed(params, values1, values2).length === 0;\n  };\n  /** Returns true if a the parameter values are valid, according to the Param definitions */\n\n\n  Param.validates = function (params, values) {\n    if (values === void 0) {\n      values = {};\n    }\n\n    return params.map(function (param) {\n      return param.validates(values[param.id]);\n    }).reduce(allTrueR, true);\n  };\n\n  Param.prototype.isDefaultValue = function (value) {\n    return this.isOptional && this.type.equals(this.value(), value);\n  };\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n\n\n  Param.prototype.value = function (value) {\n    var _this = this;\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n\n\n    var getDefaultValue = function () {\n      if (_this._defaultValueCache) return _this._defaultValueCache.defaultValue;\n      if (!services.$injector) throw new Error('Injectable functions cannot be called at configuration time');\n      var defaultValue = services.$injector.invoke(_this.config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue)) throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\n      if (_this.config.$$fn['__cacheable']) {\n        _this._defaultValueCache = {\n          defaultValue: defaultValue\n        };\n      }\n\n      return defaultValue;\n    };\n\n    var replaceSpecialValues = function (val) {\n      for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n        var tuple = _a[_i];\n        if (tuple.from === val) return tuple.to;\n      }\n\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  };\n\n  Param.prototype.isSearch = function () {\n    return this.location === DefType.SEARCH;\n  };\n\n  Param.prototype.validates = function (value) {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true; // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\n    var normalized = this.type.$normalize(value);\n    if (!this.type.is(normalized)) return false; // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\n    var encoded = this.type.encode(normalized);\n    return !(isString(encoded) && !this.type.pattern.exec(encoded));\n  };\n\n  Param.prototype.toString = function () {\n    return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n  };\n\n  return Param;\n}();\n\nexport { Param };","map":{"version":3,"sources":["@uirouter/core/params/param.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module params */\nimport { extend, filter, map, allTrueR, find } from '../common/common';\nimport { prop } from '../common/hof';\nimport { isInjectable, isDefined, isString, isArray, isUndefined } from '../common/predicates';\nimport { RawParams, ParamDeclaration } from '../params/interface';\nimport { services } from '../common/coreservices';\nimport { ParamType } from './paramType';\nimport { ParamTypes } from './paramTypes';\nimport { StateDeclaration } from '../state';\nimport { UrlConfig } from '../url';\n\n/** @hidden */\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/** @hidden */\nconst isShorthand = (cfg: ParamDeclaration) =>\n  ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;\n\n/** @internalapi */\nenum DefType {\n  PATH,\n  SEARCH,\n  CONFIG,\n}\nexport { DefType };\n\n/** @internalapi */\nfunction getParamDeclaration(paramName: string, location: DefType, state: StateDeclaration): ParamDeclaration {\n  const noReloadOnSearch = (state.reloadOnSearch === false && location === DefType.SEARCH) || undefined;\n  const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);\n  const defaultConfig = isDefined(dynamic) ? { dynamic } : {};\n  const paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);\n  return extend(defaultConfig, paramConfig);\n}\n\n/** @hidden */\nfunction unwrapShorthand(cfg: ParamDeclaration): ParamDeclaration {\n  cfg = isShorthand(cfg) ? ({ value: cfg } as ParamDeclaration) : cfg;\n\n  getStaticDefaultValue['__cacheable'] = true;\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n\n  const $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;\n  return extend(cfg, { $$fn });\n}\n\n/** @hidden */\nfunction getType(cfg: ParamDeclaration, urlType: ParamType, location: DefType, id: string, paramTypes: ParamTypes) {\n  if (cfg.type && urlType && urlType.name !== 'string') throw new Error(`Param '${id}' has two type configurations.`);\n  if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type as string))\n    return paramTypes.type(cfg.type as string);\n  if (urlType) return urlType;\n  if (!cfg.type) {\n    const type =\n      location === DefType.CONFIG\n        ? 'any'\n        : location === DefType.PATH\n        ? 'path'\n        : location === DefType.SEARCH\n        ? 'query'\n        : 'string';\n    return paramTypes.type(type);\n  }\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type as string);\n}\n\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config: ParamDeclaration, isOptional: boolean, defaultPolicy: boolean | string) {\n  const squash = config.squash;\n  if (!isOptional || squash === false) return false;\n  if (!isDefined(squash) || squash == null) return defaultPolicy;\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(`Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`);\n}\n\n/** @internalapi */\nfunction getReplace(config: ParamDeclaration, arrayMode: boolean, isOptional: boolean, squash: string | boolean) {\n  const defaultPolicy = [\n    { from: '', to: isOptional || arrayMode ? undefined : '' },\n    { from: null, to: isOptional || arrayMode ? undefined : '' },\n  ];\n\n  const replace = isArray(config.replace) ? config.replace : [];\n  if (isString(squash)) replace.push({ from: squash, to: undefined });\n\n  const configuredKeys = map(replace, prop('from'));\n  return filter(defaultPolicy, item => configuredKeys.indexOf(item.from) === -1).concat(replace);\n}\n\n/** @internalapi */\nexport class Param {\n  id: string;\n  type: ParamType;\n  location: DefType;\n  isOptional: boolean;\n  dynamic: boolean;\n  raw: boolean;\n  squash: boolean | string;\n  replace: [{ to: any; from: any }];\n  inherit: boolean;\n  array: boolean;\n  config: any;\n  /** Cache the default value if it is a static value */\n  _defaultValueCache: {\n    defaultValue: any;\n  };\n\n  static values(params: Param[], values: RawParams = {}): RawParams {\n    const paramValues = {} as RawParams;\n    for (const param of params) {\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n    return paramValues;\n  }\n\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   *\n   * @param params: The list of Param objects to filter\n   * @param values1: The first set of parameter values\n   * @param values2: the second set of parameter values\n   *\n   * @returns any Param objects whose values were different between values1 and values2\n   */\n  static changed(params: Param[], values1: RawParams = {}, values2: RawParams = {}): Param[] {\n    return params.filter(param => !param.type.equals(values1[param.id], values2[param.id]));\n  }\n\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   *\n   * @param params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   *\n   * @returns true if the param values in values1 and values2 are equal\n   */\n  static equals(params: Param[], values1 = {}, values2 = {}): boolean {\n    return Param.changed(params, values1, values2).length === 0;\n  }\n\n  /** Returns true if a the parameter values are valid, according to the Param definitions */\n  static validates(params: Param[], values: RawParams = {}): boolean {\n    return params.map(param => param.validates(values[param.id])).reduce(allTrueR, true);\n  }\n\n  constructor(id: string, type: ParamType, location: DefType, urlConfig: UrlConfig, state: StateDeclaration) {\n    const config: ParamDeclaration = getParamDeclaration(id, location, state);\n    type = getType(config, type, location, id, urlConfig.paramTypes);\n    const arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n    const isOptional = config.value !== undefined || location === DefType.SEARCH;\n    const dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n    const raw = isDefined(config.raw) ? !!config.raw : !!type.raw;\n    const squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy());\n    const replace = getReplace(config, arrayMode, isOptional, squash);\n    const inherit = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      const arrayDefaults = { array: location === DefType.SEARCH ? 'auto' : false };\n      const arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    extend(this, { id, type, location, isOptional, dynamic, raw, squash, replace, inherit, array: arrayMode, config });\n  }\n\n  isDefaultValue(value: any): boolean {\n    return this.isOptional && this.type.equals(this.value(), value);\n  }\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   */\n  value(value?: any): any {\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    const getDefaultValue = () => {\n      if (this._defaultValueCache) return this._defaultValueCache.defaultValue;\n\n      if (!services.$injector) throw new Error('Injectable functions cannot be called at configuration time');\n\n      const defaultValue = services.$injector.invoke(this.config.$$fn);\n\n      if (defaultValue !== null && defaultValue !== undefined && !this.type.is(defaultValue))\n        throw new Error(\n          `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${\n            this.type.name\n          })`\n        );\n\n      if (this.config.$$fn['__cacheable']) {\n        this._defaultValueCache = { defaultValue };\n      }\n\n      return defaultValue;\n    };\n\n    const replaceSpecialValues = (val: any) => {\n      for (const tuple of this.replace) {\n        if (tuple.from === val) return tuple.to;\n      }\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  }\n\n  isSearch(): boolean {\n    return this.location === DefType.SEARCH;\n  }\n\n  validates(value: any): boolean {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true;\n\n    // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n    const normalized = this.type.$normalize(value);\n    if (!this.type.is(normalized)) return false;\n\n    // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n    const encoded = this.type.encode(normalized);\n    return !(isString(encoded) && !this.type.pattern.exec(<string>encoded));\n  }\n\n  toString() {\n    return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}