{"ast":null,"code":"/** @packageDocumentation @publicapi @module resolve */\nimport { find, tail, uniqR, unnestR, inArray } from '../common/common';\nimport { propEq, not } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { resolvePolicies } from './interface';\nimport { Resolvable } from './resolvable';\nimport { PathUtils } from '../path/pathUtils';\nimport { stringify } from '../common/strings';\nimport { isUndefined } from '../common';\nvar whens = resolvePolicies.when;\nvar ALL_WHENS = [whens.EAGER, whens.LAZY];\nvar EAGER_WHENS = [whens.EAGER]; // tslint:disable-next-line:no-inferrable-types\n\nexport var NATIVE_INJECTOR_TOKEN = 'Native Injector';\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\n\nvar ResolveContext =\n/** @class */\nfunction () {\n  function ResolveContext(_path) {\n    this._path = _path;\n  }\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n\n\n  ResolveContext.prototype.getTokens = function () {\n    return this._path.reduce(function (acc, node) {\n      return acc.concat(node.resolvables.map(function (r) {\n        return r.token;\n      }));\n    }, []).reduce(uniqR, []);\n  };\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   */\n\n\n  ResolveContext.prototype.getResolvable = function (token) {\n    var matching = this._path.map(function (node) {\n      return node.resolvables;\n    }).reduce(unnestR, []).filter(function (r) {\n      return r.token === token;\n    });\n\n    return tail(matching);\n  };\n  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\n\n  ResolveContext.prototype.getPolicy = function (resolvable) {\n    var node = this.findNode(resolvable);\n    return resolvable.getPolicy(node.state);\n  };\n  /**\n   * Returns a ResolveContext that includes a portion of this one\n   *\n   * Given a state, this method creates a new ResolveContext from this one.\n   * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n   *\n   * #### Why\n   *\n   * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n   * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n   * This method is used to create a narrower context when injecting ancestor nodes.\n   *\n   * @example\n   * `let ABCD = new ResolveContext([A, B, C, D]);`\n   *\n   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n   * However, `B` should only be able to access resolvables from `A`, `B`.\n   *\n   * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n   * `let AB = ABCD.subcontext(a)`\n   */\n\n\n  ResolveContext.prototype.subContext = function (state) {\n    return new ResolveContext(PathUtils.subPath(this._path, function (node) {\n      return node.state === state;\n    }));\n  };\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param newResolvables the new Resolvables\n   * @param state Used to find the node to put the resolvable on\n   */\n\n\n  ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n    var node = find(this._path, propEq('state', state));\n    var keys = newResolvables.map(function (r) {\n      return r.token;\n    });\n    node.resolvables = node.resolvables.filter(function (r) {\n      return keys.indexOf(r.token) === -1;\n    }).concat(newResolvables);\n  };\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param when\n   * @param trans\n   * @returns {Promise<any>|any}\n   */\n\n\n  ResolveContext.prototype.resolvePath = function (when, trans) {\n    var _this = this;\n\n    if (when === void 0) {\n      when = 'LAZY';\n    } // This option determines which 'when' policy Resolvables we are about to fetch.\n\n\n    var whenOption = inArray(ALL_WHENS, when) ? when : 'LAZY'; // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\n    var matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS; // get the subpath to the state argument, if provided\n\n    trace.traceResolvePath(this._path, when, trans);\n\n    var matchesPolicy = function (acceptedVals, whenOrAsync) {\n      return function (resolvable) {\n        return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n      };\n    }; // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n\n\n    var promises = this._path.reduce(function (acc, node) {\n      var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n      var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n      var wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async'))); // For the matching Resolvables, start their async fetch process.\n\n      var subContext = _this.subContext(node.state);\n\n      var getResult = function (r) {\n        return r.get(subContext, trans) // Return a tuple that includes the Resolvable's token\n        .then(function (value) {\n          return {\n            token: r.token,\n            value: value\n          };\n        });\n      };\n\n      nowait.forEach(getResult);\n      return acc.concat(wait.map(getResult));\n    }, []); // Wait for all the \"WAIT\" resolvables\n\n\n    return services.$q.all(promises);\n  };\n\n  ResolveContext.prototype.injector = function () {\n    return this._injector || (this._injector = new UIInjectorImpl(this));\n  };\n\n  ResolveContext.prototype.findNode = function (resolvable) {\n    return find(this._path, function (node) {\n      return inArray(node.resolvables, resolvable);\n    });\n  };\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   */\n\n\n  ResolveContext.prototype.getDependencies = function (resolvable) {\n    var _this = this;\n\n    var node = this.findNode(resolvable); // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\n    var subPath = PathUtils.subPath(this._path, function (x) {\n      return x === node;\n    }) || this._path;\n\n    var availableResolvables = subPath.reduce(function (acc, _node) {\n      return acc.concat(_node.resolvables);\n    }, []) // all of subpath's resolvables\n    .filter(function (res) {\n      return res !== resolvable;\n    }); // filter out the `resolvable` argument\n\n    var getDependency = function (token) {\n      var matching = availableResolvables.filter(function (r) {\n        return r.token === token;\n      });\n      if (matching.length) return tail(matching);\n\n      var fromInjector = _this.injector().getNative(token);\n\n      if (isUndefined(fromInjector)) {\n        throw new Error('Could not find Dependency Injection token: ' + stringify(token));\n      }\n\n      return new Resolvable(token, function () {\n        return fromInjector;\n      }, [], fromInjector);\n    };\n\n    return resolvable.deps.map(getDependency);\n  };\n\n  return ResolveContext;\n}();\n\nexport { ResolveContext };\n/** @internalapi */\n\nvar UIInjectorImpl =\n/** @class */\nfunction () {\n  function UIInjectorImpl(context) {\n    this.context = context;\n    this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n  }\n\n  UIInjectorImpl.prototype.get = function (token) {\n    var resolvable = this.context.getResolvable(token);\n\n    if (resolvable) {\n      if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n        return resolvable.get(this.context);\n      }\n\n      if (!resolvable.resolved) {\n        throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));\n      }\n\n      return resolvable.data;\n    }\n\n    return this.getNative(token);\n  };\n\n  UIInjectorImpl.prototype.getAsync = function (token) {\n    var resolvable = this.context.getResolvable(token);\n    if (resolvable) return resolvable.get(this.context);\n    return services.$q.when(this.native.get(token));\n  };\n\n  UIInjectorImpl.prototype.getNative = function (token) {\n    return this.native && this.native.get(token);\n  };\n\n  return UIInjectorImpl;\n}();","map":{"version":3,"sources":["@uirouter/core/resolve/resolveContext.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module resolve */\nimport { find, tail, uniqR, unnestR, inArray } from '../common/common';\nimport { propEq, not } from '../common/hof';\nimport { trace } from '../common/trace';\nimport { services, $InjectorLike } from '../common/coreservices';\nimport { resolvePolicies, PolicyWhen, ResolvePolicy } from './interface';\nimport { PathNode } from '../path/pathNode';\nimport { Resolvable } from './resolvable';\nimport { StateObject } from '../state/stateObject';\nimport { PathUtils } from '../path/pathUtils';\nimport { stringify } from '../common/strings';\nimport { Transition } from '../transition/transition';\nimport { UIInjector } from '../interface';\nimport { isUndefined } from '../common';\n\nconst whens = resolvePolicies.when;\nconst ALL_WHENS = [whens.EAGER, whens.LAZY];\nconst EAGER_WHENS = [whens.EAGER];\n\n// tslint:disable-next-line:no-inferrable-types\nexport const NATIVE_INJECTOR_TOKEN: string = 'Native Injector';\n\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nexport class ResolveContext {\n  _injector: UIInjector;\n\n  constructor(private _path: PathNode[]) {}\n\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n  getTokens(): any[] {\n    return this._path.reduce((acc, node) => acc.concat(node.resolvables.map(r => r.token)), []).reduce(uniqR, []);\n  }\n\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   */\n  getResolvable(token: any): Resolvable {\n    const matching = this._path\n      .map(node => node.resolvables)\n      .reduce(unnestR, [])\n      .filter((r: Resolvable) => r.token === token);\n    return tail(matching);\n  }\n\n  /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n  getPolicy(resolvable: Resolvable): ResolvePolicy {\n    const node = this.findNode(resolvable);\n    return resolvable.getPolicy(node.state);\n  }\n\n  /**\n   * Returns a ResolveContext that includes a portion of this one\n   *\n   * Given a state, this method creates a new ResolveContext from this one.\n   * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n   *\n   * #### Why\n   *\n   * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n   * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n   * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n   * This method is used to create a narrower context when injecting ancestor nodes.\n   *\n   * @example\n   * `let ABCD = new ResolveContext([A, B, C, D]);`\n   *\n   * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n   * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n   * However, `B` should only be able to access resolvables from `A`, `B`.\n   *\n   * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n   * `let AB = ABCD.subcontext(a)`\n   */\n  subContext(state: StateObject): ResolveContext {\n    return new ResolveContext(PathUtils.subPath(this._path, node => node.state === state));\n  }\n\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param newResolvables the new Resolvables\n   * @param state Used to find the node to put the resolvable on\n   */\n  addResolvables(newResolvables: Resolvable[], state: StateObject) {\n    const node = <PathNode>find(this._path, propEq('state', state));\n    const keys = newResolvables.map(r => r.token);\n    node.resolvables = node.resolvables.filter(r => keys.indexOf(r.token) === -1).concat(newResolvables);\n  }\n\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param when\n   * @param trans\n   * @returns {Promise<any>|any}\n   */\n  resolvePath(when: PolicyWhen = 'LAZY', trans?: Transition): Promise<{ token: any; value: any }[]> {\n    // This option determines which 'when' policy Resolvables we are about to fetch.\n    const whenOption: string = inArray(ALL_WHENS, when) ? when : 'LAZY';\n    // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n    const matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\n    // get the subpath to the state argument, if provided\n    trace.traceResolvePath(this._path, when, trans);\n\n    const matchesPolicy = (acceptedVals: string[], whenOrAsync: 'when' | 'async') => (resolvable: Resolvable) =>\n      inArray(acceptedVals, this.getPolicy(resolvable)[whenOrAsync]);\n\n    // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n    const promises: Promise<any>[] = this._path.reduce((acc, node) => {\n      const nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n      const nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n      const wait = nodeResolvables.filter(not(matchesPolicy(['NOWAIT'], 'async')));\n\n      // For the matching Resolvables, start their async fetch process.\n      const subContext = this.subContext(node.state);\n      const getResult = (r: Resolvable) =>\n        r\n          .get(subContext, trans)\n          // Return a tuple that includes the Resolvable's token\n          .then(value => ({ token: r.token, value: value }));\n      nowait.forEach(getResult);\n      return acc.concat(wait.map(getResult));\n    }, []);\n\n    // Wait for all the \"WAIT\" resolvables\n    return services.$q.all(promises);\n  }\n\n  injector(): UIInjector {\n    return this._injector || (this._injector = new UIInjectorImpl(this));\n  }\n\n  findNode(resolvable: Resolvable): PathNode {\n    return find(this._path, (node: PathNode) => inArray(node.resolvables, resolvable));\n  }\n\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   */\n  getDependencies(resolvable: Resolvable): Resolvable[] {\n    const node = this.findNode(resolvable);\n    // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n    const subPath: PathNode[] = PathUtils.subPath(this._path, x => x === node) || this._path;\n    const availableResolvables: Resolvable[] = subPath\n      .reduce((acc, _node) => acc.concat(_node.resolvables), []) // all of subpath's resolvables\n      .filter(res => res !== resolvable); // filter out the `resolvable` argument\n\n    const getDependency = (token: any) => {\n      const matching = availableResolvables.filter(r => r.token === token);\n      if (matching.length) return tail(matching);\n\n      const fromInjector = this.injector().getNative(token);\n      if (isUndefined(fromInjector)) {\n        throw new Error('Could not find Dependency Injection token: ' + stringify(token));\n      }\n\n      return new Resolvable(token, () => fromInjector, [], fromInjector);\n    };\n\n    return resolvable.deps.map(getDependency);\n  }\n}\n\n/** @internalapi */\nclass UIInjectorImpl implements UIInjector {\n  native: $InjectorLike;\n\n  constructor(public context: ResolveContext) {\n    this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;\n  }\n\n  get(token: any) {\n    const resolvable = this.context.getResolvable(token);\n    if (resolvable) {\n      if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n        return resolvable.get(this.context);\n      }\n\n      if (!resolvable.resolved) {\n        throw new Error('Resolvable async .get() not complete:' + stringify(resolvable.token));\n      }\n      return resolvable.data;\n    }\n\n    return this.getNative(token);\n  }\n\n  getAsync(token: any) {\n    const resolvable = this.context.getResolvable(token);\n    if (resolvable) return resolvable.get(this.context);\n    return services.$q.when(this.native.get(token));\n  }\n\n  getNative(token: any) {\n    return this.native && this.native.get(token);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}