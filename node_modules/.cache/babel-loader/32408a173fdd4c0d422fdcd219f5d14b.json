{"ast":null,"code":"/** @packageDocumentation @internalapi @module hooks */\nimport { Transition } from '../transition/transition';\nimport { UIRouter } from '../router';\nimport { Resolvable } from '../resolve';\nimport { inArray, uniqR, unnestR, values } from '../common';\n\nfunction addCoreResolvables(trans) {\n  trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');\n  trans.addResolvable(Resolvable.fromData(Transition, trans), '');\n  trans.addResolvable(Resolvable.fromData('$transition$', trans), '');\n  trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');\n  trans.entering().forEach(function (state) {\n    trans.addResolvable(Resolvable.fromData('$state$', state), state);\n  });\n}\n\nexport var registerAddCoreResolvables = function (transitionService) {\n  return transitionService.onCreate({}, addCoreResolvables);\n};\nvar TRANSITION_TOKENS = ['$transition$', Transition];\nvar isTransition = inArray(TRANSITION_TOKENS); // References to Transition in the treeChanges pathnodes makes all\n// previous Transitions reachable in memory, causing a memory leak\n// This function removes resolves for '$transition$' and `Transition` from the treeChanges.\n// Do not use this on current transitions, only on old ones.\n\nexport var treeChangesCleanup = function (trans) {\n  var nodes = values(trans.treeChanges()).reduce(unnestR, []).reduce(uniqR, []); // If the resolvable is a Transition, return a new resolvable with null data\n\n  var replaceTransitionWithNull = function (r) {\n    return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;\n  };\n\n  nodes.forEach(function (node) {\n    node.resolvables = node.resolvables.map(replaceTransitionWithNull);\n  });\n};","map":{"version":3,"sources":["@uirouter/core/hooks/coreResolvables.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,UAAT,QAA2B,0BAA3B;AACA,SAAS,QAAT,QAAyB,WAAzB;AAEA,SAAS,UAAT,QAA2B,YAA3B;AACA,SAAS,OAAT,EAAkB,KAAlB,EAAyB,OAAzB,EAAkC,MAAlC,QAAgD,WAAhD;;AAGA,SAAS,kBAAT,CAA4B,KAA5B,EAA6C;AAC3C,EAAA,KAAK,CAAC,aAAN,CAAoB,UAAU,CAAC,QAAX,CAAoB,QAApB,EAA8B,KAAK,CAAC,MAApC,CAApB,EAAiE,EAAjE;AACA,EAAA,KAAK,CAAC,aAAN,CAAoB,UAAU,CAAC,QAAX,CAAoB,UAApB,EAAgC,KAAhC,CAApB,EAA4D,EAA5D;AACA,EAAA,KAAK,CAAC,aAAN,CAAoB,UAAU,CAAC,QAAX,CAAoB,cAApB,EAAoC,KAApC,CAApB,EAAgE,EAAhE;AACA,EAAA,KAAK,CAAC,aAAN,CAAoB,UAAU,CAAC,QAAX,CAAoB,cAApB,EAAoC,KAAK,CAAC,MAAN,EAApC,CAApB,EAAyE,EAAzE;AAEA,EAAA,KAAK,CAAC,QAAN,GAAiB,OAAjB,CAAyB,UAAA,KAAA,EAAK;AAC5B,IAAA,KAAK,CAAC,aAAN,CAAoB,UAAU,CAAC,QAAX,CAAoB,SAApB,EAA+B,KAA/B,CAApB,EAA2D,KAA3D;AACD,GAFD;AAGD;;AAED,OAAO,IAAM,0BAA0B,GAAG,UAAC,iBAAD,EAAqC;AAC7E,SAAA,iBAAiB,CAAC,QAAlB,CAA2B,EAA3B,EAA+B,kBAA/B,CAAA;AAAkD,CAD7C;AAGP,IAAM,iBAAiB,GAAG,CAAC,cAAD,EAAiB,UAAjB,CAA1B;AACA,IAAM,YAAY,GAAG,OAAO,CAAC,iBAAD,CAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,IAAM,kBAAkB,GAAG,UAAC,KAAD,EAAkB;AAClD,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,WAAN,EAAD,CAAN,CACX,MADW,CACJ,OADI,EACK,EADL,EAEX,MAFW,CAEJ,KAFI,EAEG,EAFH,CAAd,CADkD,CAKlD;;AACA,MAAM,yBAAyB,GAAG,UAAC,CAAD,EAAc;AAC9C,WAAO,YAAY,CAAC,CAAC,CAAC,KAAH,CAAZ,GAAwB,UAAU,CAAC,QAAX,CAAoB,CAAC,CAAC,KAAtB,EAA6B,IAA7B,CAAxB,GAA6D,CAApE;AACD,GAFD;;AAIA,EAAA,KAAK,CAAC,OAAN,CAAc,UAAC,IAAD,EAAe;AAC3B,IAAA,IAAI,CAAC,WAAL,GAAmB,IAAI,CAAC,WAAL,CAAiB,GAAjB,CAAqB,yBAArB,CAAnB;AACD,GAFD;AAGD,CAbM","sourcesContent":["/** @packageDocumentation @internalapi @module hooks */\nimport { Transition } from '../transition/transition';\nimport { UIRouter } from '../router';\nimport { TransitionService } from '../transition/transitionService';\nimport { Resolvable } from '../resolve';\nimport { inArray, uniqR, unnestR, values } from '../common';\nimport { PathNode } from '../path';\n\nfunction addCoreResolvables(trans: Transition) {\n  trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), '');\n  trans.addResolvable(Resolvable.fromData(Transition, trans), '');\n  trans.addResolvable(Resolvable.fromData('$transition$', trans), '');\n  trans.addResolvable(Resolvable.fromData('$stateParams', trans.params()), '');\n\n  trans.entering().forEach(state => {\n    trans.addResolvable(Resolvable.fromData('$state$', state), state);\n  });\n}\n\nexport const registerAddCoreResolvables = (transitionService: TransitionService) =>\n  transitionService.onCreate({}, addCoreResolvables);\n\nconst TRANSITION_TOKENS = ['$transition$', Transition];\nconst isTransition = inArray(TRANSITION_TOKENS);\n\n// References to Transition in the treeChanges pathnodes makes all\n// previous Transitions reachable in memory, causing a memory leak\n// This function removes resolves for '$transition$' and `Transition` from the treeChanges.\n// Do not use this on current transitions, only on old ones.\nexport const treeChangesCleanup = (trans: Transition) => {\n  const nodes = values(trans.treeChanges())\n    .reduce(unnestR, [])\n    .reduce(uniqR, []);\n\n  // If the resolvable is a Transition, return a new resolvable with null data\n  const replaceTransitionWithNull = (r: Resolvable): Resolvable => {\n    return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;\n  };\n\n  nodes.forEach((node: PathNode) => {\n    node.resolvables = node.resolvables.map(replaceTransitionWithNull);\n  });\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}