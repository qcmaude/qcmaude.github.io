{"ast":null,"code":"/** @packageDocumentation @internalapi @module hooks */\nimport { noop } from '../common/common';\nimport { services } from '../common/coreservices';\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\n\nvar loadEnteringViews = function (transition) {\n  var $q = services.$q;\n  var enteringViews = transition.views('entering');\n  if (!enteringViews.length) return;\n  return $q.all(enteringViews.map(function (view) {\n    return $q.when(view.load());\n  })).then(noop);\n};\n\nexport var registerLoadEnteringViews = function (transitionService) {\n  return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\n\nvar activateViews = function (transition) {\n  var enteringViews = transition.views('entering');\n  var exitingViews = transition.views('exiting');\n  if (!enteringViews.length && !exitingViews.length) return;\n  var $view = transition.router.viewService;\n  exitingViews.forEach(function (vc) {\n    return $view.deactivateViewConfig(vc);\n  });\n  enteringViews.forEach(function (vc) {\n    return $view.activateViewConfig(vc);\n  });\n  $view.sync();\n};\n\nexport var registerActivateViews = function (transitionService) {\n  return transitionService.onSuccess({}, activateViews);\n};","map":{"version":3,"sources":["@uirouter/core/hooks/views.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,IAAT,QAAqB,kBAArB;AACA,SAAS,QAAT,QAAyB,wBAAzB;AAOA;;;;;;;AAOG;;AACH,IAAM,iBAAiB,GAAqB,UAAC,UAAD,EAAuB;AACjE,MAAM,EAAE,GAAG,QAAQ,CAAC,EAApB;AACA,MAAM,aAAa,GAAG,UAAU,CAAC,KAAX,CAAiB,UAAjB,CAAtB;AACA,MAAI,CAAC,aAAa,CAAC,MAAnB,EAA2B;AAC3B,SAAO,EAAE,CAAC,GAAH,CAAO,aAAa,CAAC,GAAd,CAAkB,UAAA,IAAA,EAAI;AAAI,WAAA,EAAE,CAAC,IAAH,CAAQ,IAAI,CAAZ,IAAQ,EAAR,CAAA;AAAoB,GAA9C,CAAP,EAAwD,IAAxD,CAA6D,IAA7D,CAAP;AACD,CALD;;AAOA,OAAO,IAAM,yBAAyB,GAAG,UAAC,iBAAD,EAAqC;AAC5E,SAAA,iBAAiB,CAAC,QAAlB,CAA2B,EAA3B,EAA+B,iBAA/B,CAAA;AAAiD,CAD5C;AAGP;;;;;;;;;AASG;;AACH,IAAM,aAAa,GAAqB,UAAC,UAAD,EAAuB;AAC7D,MAAM,aAAa,GAAG,UAAU,CAAC,KAAX,CAAiB,UAAjB,CAAtB;AACA,MAAM,YAAY,GAAG,UAAU,CAAC,KAAX,CAAiB,SAAjB,CAArB;AACA,MAAI,CAAC,aAAa,CAAC,MAAf,IAAyB,CAAC,YAAY,CAAC,MAA3C,EAAmD;AAEnD,MAAM,KAAK,GAAgB,UAAU,CAAC,MAAX,CAAkB,WAA7C;AAEA,EAAA,YAAY,CAAC,OAAb,CAAqB,UAAC,EAAD,EAAe;AAAK,WAAA,KAAK,CAAC,oBAAN,CAAA,EAAA,CAAA;AAA8B,GAAvE;AACA,EAAA,aAAa,CAAC,OAAd,CAAsB,UAAC,EAAD,EAAe;AAAK,WAAA,KAAK,CAAC,kBAAN,CAAA,EAAA,CAAA;AAA4B,GAAtE;AAEA,EAAA,KAAK,CAAC,IAAN;AACD,CAXD;;AAaA,OAAO,IAAM,qBAAqB,GAAG,UAAC,iBAAD,EAAqC;AACxE,SAAA,iBAAiB,CAAC,SAAlB,CAA4B,EAA5B,EAAgC,aAAhC,CAAA;AAA8C,CADzC","sourcesContent":["/** @packageDocumentation @internalapi @module hooks */\nimport { noop } from '../common/common';\nimport { services } from '../common/coreservices';\nimport { Transition } from '../transition/transition';\nimport { ViewService } from '../view/view';\nimport { ViewConfig } from '../view/interface';\nimport { TransitionHookFn } from '../transition/interface';\nimport { TransitionService } from '../transition/transitionService';\n\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nconst loadEnteringViews: TransitionHookFn = (transition: Transition) => {\n  const $q = services.$q;\n  const enteringViews = transition.views('entering');\n  if (!enteringViews.length) return;\n  return $q.all(enteringViews.map(view => $q.when(view.load()))).then(noop);\n};\n\nexport const registerLoadEnteringViews = (transitionService: TransitionService) =>\n  transitionService.onFinish({}, loadEnteringViews);\n\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nconst activateViews: TransitionHookFn = (transition: Transition) => {\n  const enteringViews = transition.views('entering');\n  const exitingViews = transition.views('exiting');\n  if (!enteringViews.length && !exitingViews.length) return;\n\n  const $view: ViewService = transition.router.viewService;\n\n  exitingViews.forEach((vc: ViewConfig) => $view.deactivateViewConfig(vc));\n  enteringViews.forEach((vc: ViewConfig) => $view.activateViewConfig(vc));\n\n  $view.sync();\n};\n\nexport const registerActivateViews = (transitionService: TransitionService) =>\n  transitionService.onSuccess({}, activateViews);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}