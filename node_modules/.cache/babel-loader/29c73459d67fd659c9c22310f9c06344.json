{"ast":null,"code":"/** @packageDocumentation @internalapi @module vanilla */\nimport { isArray, isObject } from '../common/index';\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\n\nexport var $q = {\n  /** Normalizes a value as a promise */\n  when: function (val) {\n    return new Promise(function (resolve, reject) {\n      return resolve(val);\n    });\n  },\n\n  /** Normalizes a value as a promise rejection */\n  reject: function (val) {\n    return new Promise(function (resolve, reject) {\n      reject(val);\n    });\n  },\n\n  /** @returns a deferred object, which has `resolve` and `reject` functions */\n  defer: function () {\n    var deferred = {};\n    deferred.promise = new Promise(function (resolve, reject) {\n      deferred.resolve = resolve;\n      deferred.reject = reject;\n    });\n    return deferred;\n  },\n\n  /** Like Promise.all(), but also supports object key/promise notation like $q */\n  all: function (promises) {\n    if (isArray(promises)) {\n      return Promise.all(promises);\n    }\n\n    if (isObject(promises)) {\n      // Convert promises map to promises array.\n      // When each promise resolves, map it to a tuple { key: key, val: val }\n      var chain = Object.keys(promises).map(function (key) {\n        return promises[key].then(function (val) {\n          return {\n            key: key,\n            val: val\n          };\n        });\n      }); // Then wait for all promises to resolve, and convert them back to an object\n\n      return $q.all(chain).then(function (values) {\n        return values.reduce(function (acc, tuple) {\n          acc[tuple.key] = tuple.val;\n          return acc;\n        }, {});\n      });\n    }\n  }\n};","map":{"version":3,"sources":["@uirouter/core/vanilla/q.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,OAAT,EAAkB,QAAlB,QAA0C,iBAA1C;AAEA;;;;;;;;;;;;;;AAcG;;AACH,OAAO,IAAM,EAAE,GAAG;AAChB;AACA,EAAA,IAAI,EAAE,UAAA,GAAA,EAAG;AAAI,WAAA,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAAK,aAAA,OAAO,CAAP,GAAO,CAAP;AAAjC,KAAA,CAAA;AAA8C,GAF3C;;AAIhB;AACA,EAAA,MAAM,EAAE,UAAA,GAAA,EAAG;AACT,WAAA,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC1B,MAAA,MAAM,CAAC,GAAD,CAAN;AACD,KAFD,CAAA;AAEE,GARY;;AAUhB;AACA,EAAA,KAAK,EAAE,YAAA;AACL,QAAM,QAAQ,GAAQ,EAAtB;AACA,IAAA,QAAQ,CAAC,OAAT,GAAmB,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC7C,MAAA,QAAQ,CAAC,OAAT,GAAmB,OAAnB;AACA,MAAA,QAAQ,CAAC,MAAT,GAAkB,MAAlB;AACD,KAHkB,CAAnB;AAIA,WAAO,QAAP;AACD,GAlBe;;AAoBhB;AACA,EAAA,GAAG,EAAE,UAAC,QAAD,EAA2D;AAC9D,QAAI,OAAO,CAAC,QAAD,CAAX,EAAuB;AACrB,aAAO,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAP;AACD;;AAED,QAAI,QAAQ,CAAC,QAAD,CAAZ,EAAwB;AACtB;AACA;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,QAAZ,EAAsB,GAAtB,CAA0B,UAAA,GAAA,EAAG;AAAI,eAAA,QAAQ,CAAC,GAAD,CAAR,CAAc,IAAd,CAAmB,UAAA,GAAA,EAAG;AAAI,iBAAC;AAAE,YAAA,GAAG,EAAA,GAAL;AAAO,YAAA,GAAG,EAAX;AAAC,WAAD;AAA1B,SAAA,CAAA;AAAyC,OAA1E,CAAd,CAHsB,CAKtB;;AACA,aAAO,EAAE,CAAC,GAAH,CAAO,KAAP,EAAc,IAAd,CAAmB,UAAA,MAAA,EAAM;AAC9B,eAAA,MAAM,CAAC,MAAP,CAAc,UAAC,GAAD,EAAM,KAAN,EAAW;AACvB,UAAA,GAAG,CAAC,KAAK,CAAC,GAAP,CAAH,GAAiB,KAAK,CAAC,GAAvB;AACA,iBAAO,GAAP;AACD,SAHD,EAGG,EAHH,CAAA;AAGM,OAJD,CAAP;AAMD;AACF;AAvCe,CAAX","sourcesContent":["/** @packageDocumentation @internalapi @module vanilla */\nimport { isArray, isObject, $QLike } from '../common/index';\n\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexport const $q = {\n  /** Normalizes a value as a promise */\n  when: val => new Promise((resolve, reject) => resolve(val)),\n\n  /** Normalizes a value as a promise rejection */\n  reject: val =>\n    new Promise((resolve, reject) => {\n      reject(val);\n    }),\n\n  /** @returns a deferred object, which has `resolve` and `reject` functions */\n  defer: () => {\n    const deferred: any = {};\n    deferred.promise = new Promise((resolve, reject) => {\n      deferred.resolve = resolve;\n      deferred.reject = reject;\n    });\n    return deferred;\n  },\n\n  /** Like Promise.all(), but also supports object key/promise notation like $q */\n  all: (promises: { [key: string]: Promise<any> } | Promise<any>[]) => {\n    if (isArray(promises)) {\n      return Promise.all(promises);\n    }\n\n    if (isObject(promises)) {\n      // Convert promises map to promises array.\n      // When each promise resolves, map it to a tuple { key: key, val: val }\n      const chain = Object.keys(promises).map(key => promises[key].then(val => ({ key, val })));\n\n      // Then wait for all promises to resolve, and convert them back to an object\n      return $q.all(chain).then(values =>\n        values.reduce((acc, tuple) => {\n          acc[tuple.key] = tuple.val;\n          return acc;\n        }, {})\n      );\n    }\n  },\n} as $QLike;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}