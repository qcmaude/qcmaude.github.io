{"ast":null,"code":"/** @packageDocumentation @publicapi @module transition */\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { stringify } from '../common/strings';\nimport { map, find, extend, mergeR, tail, omit, arrayTuples, unnestR, identity, anyTrueR } from '../common/common';\nimport { isObject, isUndefined } from '../common/predicates';\nimport { prop, propEq, val, not, is } from '../common/hof';\nimport { TransitionHookPhase } from './interface'; // has or is using\n\nimport { TransitionHook } from './transitionHook';\nimport { matchState, makeEvent } from './hookRegistry';\nimport { HookBuilder } from './hookBuilder';\nimport { PathUtils } from '../path/pathUtils';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { Rejection } from './rejectFactory';\nimport { flattenR, uniqR } from '../common';\n/** @hidden */\n\nvar stateSelf = prop('self');\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\n\nvar Transition =\n/** @class */\nfunction () {\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @internalapi\n   *\n   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param router The [[UIRouter]] instance\n   */\n  function Transition(fromPath, targetState, router) {\n    var _this = this;\n    /** @hidden */\n\n\n    this._deferred = services.$q.defer();\n    /**\n     * This promise is resolved or rejected based on the outcome of the Transition.\n     *\n     * When the transition is successful, the promise is resolved\n     * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n     */\n\n    this.promise = this._deferred.promise;\n    /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n\n    this._registeredHooks = {};\n    /** @hidden */\n\n    this._hookBuilder = new HookBuilder(this);\n    /** Checks if this transition is currently active/running. */\n\n    this.isActive = function () {\n      return _this.router.globals.transition === _this;\n    };\n\n    this.router = router;\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    } // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\n\n    this._options = extend({\n      current: val(this)\n    }, targetState.options());\n    this.$id = router.transitionService._transitionCount++;\n    var toPath = PathUtils.buildToPath(fromPath, targetState);\n    this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n    this.createTransitionHookRegFns();\n\n    var onCreateHooks = this._hookBuilder.buildHooksForPhase(TransitionHookPhase.CREATE);\n\n    TransitionHook.invokeHooks(onCreateHooks, function () {\n      return null;\n    });\n    this.applyViewConfigs(router);\n  }\n  /** @hidden */\n\n\n  Transition.prototype.onBefore = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onStart = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onExit = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onRetain = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onEnter = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onFinish = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onSuccess = function (criteria, callback, options) {\n    return;\n  };\n  /** @inheritdoc */\n\n\n  Transition.prototype.onError = function (criteria, callback, options) {\n    return;\n  };\n  /** @hidden\n   * Creates the transition-level hook registration functions\n   * (which can then be used to register hooks)\n   */\n\n\n  Transition.prototype.createTransitionHookRegFns = function () {\n    var _this = this;\n\n    this.router.transitionService._pluginapi._getEvents().filter(function (type) {\n      return type.hookPhase !== TransitionHookPhase.CREATE;\n    }).forEach(function (type) {\n      return makeEvent(_this, _this.router.transitionService, type);\n    });\n  };\n  /** @internalapi */\n\n\n  Transition.prototype.getHooks = function (hookName) {\n    return this._registeredHooks[hookName];\n  };\n\n  Transition.prototype.applyViewConfigs = function (router) {\n    var enteringStates = this._treeChanges.entering.map(function (node) {\n      return node.state;\n    });\n\n    PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n  };\n  /**\n   * @internalapi\n   *\n   * @returns the internal from [State] object\n   */\n\n\n  Transition.prototype.$from = function () {\n    return tail(this._treeChanges.from).state;\n  };\n  /**\n   * @internalapi\n   *\n   * @returns the internal to [State] object\n   */\n\n\n  Transition.prototype.$to = function () {\n    return tail(this._treeChanges.to).state;\n  };\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns The state declaration object for the Transition's (\"from state\").\n   */\n\n\n  Transition.prototype.from = function () {\n    return this.$from().self;\n  };\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns The state declaration object for the Transition's target state (\"to state\").\n   */\n\n\n  Transition.prototype.to = function () {\n    return this.$to().self;\n  };\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns the [[TargetState]] of this Transition\n   */\n\n\n  Transition.prototype.targetState = function () {\n    return this._targetState;\n  };\n  /**\n   * Determines whether two transitions are equivalent.\n   * @deprecated\n   */\n\n\n  Transition.prototype.is = function (compare) {\n    if (compare instanceof Transition) {\n      // TODO: Also compare parameters\n      return this.is({\n        to: compare.$to().name,\n        from: compare.$from().name\n      });\n    }\n\n    return !(compare.to && !matchState(this.$to(), compare.to, this) || compare.from && !matchState(this.$from(), compare.from, this));\n  };\n\n  Transition.prototype.params = function (pathname) {\n    if (pathname === void 0) {\n      pathname = 'to';\n    }\n\n    return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));\n  };\n\n  Transition.prototype.paramsChanged = function () {\n    var fromParams = this.params('from');\n    var toParams = this.params('to'); // All the parameters declared on both the \"to\" and \"from\" paths\n\n    var allParamDescriptors = [].concat(this._treeChanges.to).concat(this._treeChanges.from).map(function (pathNode) {\n      return pathNode.paramSchema;\n    }).reduce(flattenR, []).reduce(uniqR, []);\n    var changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);\n    return changedParamDescriptors.reduce(function (changedValues, descriptor) {\n      changedValues[descriptor.id] = toParams[descriptor.id];\n      return changedValues;\n    }, {});\n  };\n  /**\n   * Creates a [[UIInjector]] Dependency Injector\n   *\n   * Returns a Dependency Injector for the Transition's target state (to state).\n   * The injector provides resolve values which the target state has access to.\n   *\n   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n   *\n   * #### Example:\n   * ```js\n   * .onEnter({ entering: 'myState' }, trans => {\n   *   var myResolveValue = trans.injector().get('myResolve');\n   *   // Inject a global service from the global/native injector (if it exists)\n   *   var MyService = trans.injector().get('MyService');\n   * })\n   * ```\n   *\n   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n   * You can use [[UIInjector.getAsync]] to get a promise for the data.\n   * #### Example:\n   * ```js\n   * .onBefore({}, trans => {\n   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n   *     return myResolveValue !== 'ABORT';\n   *   });\n   * });\n   * ```\n   *\n   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n   * #### Example:\n   * ```js\n   * .onEnter({ to: 'foo.bar' }, trans => {\n   *   // returns result of `foo` state's `myResolve` resolve\n   *   // even though `foo.bar` also has a `myResolve` resolve\n   *   var fooData = trans.injector('foo').get('myResolve');\n   * });\n   * ```\n   *\n   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n   * The resolve data from the `from` path will be returned.\n   * #### Example:\n   * ```js\n   * .onExit({ exiting: 'foo.bar' }, trans => {\n   *   // Gets the resolve value of `myResolve` from the state being exited\n   *   var fooData = trans.injector(null, 'from').get('myResolve');\n   * });\n   * ```\n   *\n   *\n   * @param state Limits the resolves provided to only the resolves the provided state has access to.\n   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n   *\n   * @returns a [[UIInjector]]\n   */\n\n\n  Transition.prototype.injector = function (state, pathName) {\n    if (pathName === void 0) {\n      pathName = 'to';\n    }\n\n    var path = this._treeChanges[pathName];\n    if (state) path = PathUtils.subPath(path, function (node) {\n      return node.state === state || node.state.name === state;\n    });\n    return new ResolveContext(path).injector();\n  };\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n\n\n  Transition.prototype.getResolveTokens = function (pathname) {\n    if (pathname === void 0) {\n      pathname = 'to';\n    }\n\n    return new ResolveContext(this._treeChanges[pathname]).getTokens();\n  };\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * Allows a transition hook to dynamically add a Resolvable to this Transition.\n   *\n   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n   *\n   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n   * If no `state` is provided then the root state is used.\n   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n   *\n   * The `state` argument also scopes the resolved data.\n   * The resolved data is available from the injector for that `state` and any children states.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n\n\n  Transition.prototype.addResolvable = function (resolvable, state) {\n    if (state === void 0) {\n      state = '';\n    }\n\n    resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n    var stateName = typeof state === 'string' ? state : state.name;\n    var topath = this._treeChanges.to;\n    var targetNode = find(topath, function (node) {\n      return node.state.name === stateName;\n    });\n    var resolveContext = new ResolveContext(topath);\n    resolveContext.addResolvables([resolvable], targetNode.state);\n  };\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns The previous Transition, or null if this Transition is not the result of a redirection\n   */\n\n\n  Transition.prototype.redirectedFrom = function () {\n    return this._options.redirectedFrom || null;\n  };\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns The original Transition that started a redirect chain\n   */\n\n\n  Transition.prototype.originalTransition = function () {\n    var rf = this.redirectedFrom();\n    return rf && rf.originalTransition() || this;\n  };\n  /**\n   * Get the transition options\n   *\n   * @returns the options for this Transition.\n   */\n\n\n  Transition.prototype.options = function () {\n    return this._options;\n  };\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n\n\n  Transition.prototype.entering = function () {\n    return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n  };\n  /**\n   * Gets the states being exited.\n   *\n   * @returns an array of states that will be exited during this transition.\n   */\n\n\n  Transition.prototype.exiting = function () {\n    return map(this._treeChanges.exiting, prop('state')).map(stateSelf).reverse();\n  };\n  /**\n   * Gets the states being retained.\n   *\n   * @returns an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n\n\n  Transition.prototype.retained = function () {\n    return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n  };\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns a list of ViewConfig objects for the given path.\n   */\n\n\n  Transition.prototype.views = function (pathname, state) {\n    if (pathname === void 0) {\n      pathname = 'entering';\n    }\n\n    var path = this._treeChanges[pathname];\n    path = !state ? path : path.filter(propEq('state', state));\n    return path.map(prop('views')).filter(identity).reduce(unnestR, []);\n  };\n\n  Transition.prototype.treeChanges = function (pathname) {\n    return pathname ? this._treeChanges[pathname] : this._treeChanges;\n  };\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @internalapi\n   *\n   * @returns Returns a new [[Transition]] instance.\n   */\n\n\n  Transition.prototype.redirect = function (targetState) {\n    var redirects = 1,\n        trans = this; // tslint:disable-next-line:no-conditional-assignment\n\n    while ((trans = trans.redirectedFrom()) != null) {\n      if (++redirects > 20) throw new Error(\"Too many consecutive Transition redirects (20+)\");\n    }\n\n    var redirectOpts = {\n      redirectedFrom: this,\n      source: 'redirect'\n    }; // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n\n    if (this.options().source === 'url' && targetState.options().location !== false) {\n      redirectOpts.location = 'replace';\n    }\n\n    var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n    targetState = targetState.withOptions(newOptions, true);\n    var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n    var originalEnteringNodes = this._treeChanges.entering;\n    var redirectEnteringNodes = newTransition._treeChanges.entering; // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n\n    var nodeIsReloading = function (reloadState) {\n      return function (node) {\n        return reloadState && node.state.includes[reloadState.name];\n      };\n    }; // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\n\n    var matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams).filter(not(nodeIsReloading(targetState.options().reloadState))); // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\n    matchingEnteringNodes.forEach(function (node, idx) {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n    return newTransition;\n  };\n  /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\n\n  Transition.prototype._changedParams = function () {\n    var tc = this._treeChanges;\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n\n    if (this._options.reload) return undefined; // If any states are exiting or entering\n\n    if (tc.exiting.length || tc.entering.length) return undefined; // If to/from path lengths differ\n\n    if (tc.to.length !== tc.from.length) return undefined; // If the to/from paths are different\n\n    var pathsDiffer = arrayTuples(tc.to, tc.from).map(function (tuple) {\n      return tuple[0].state !== tuple[1].state;\n    }).reduce(anyTrueR, false);\n    if (pathsDiffer) return undefined; // Find any parameter values that differ\n\n    var nodeSchemas = tc.to.map(function (node) {\n      return node.paramSchema;\n    });\n\n    var _a = [tc.to, tc.from].map(function (path) {\n      return path.map(function (x) {\n        return x.paramValues;\n      });\n    }),\n        toValues = _a[0],\n        fromValues = _a[1];\n\n    var tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n    return tuples.map(function (_a) {\n      var schema = _a[0],\n          toVals = _a[1],\n          fromVals = _a[2];\n      return Param.changed(schema, toVals, fromVals);\n    }).reduce(unnestR, []);\n  };\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns true if the Transition is dynamic\n   */\n\n\n  Transition.prototype.dynamic = function () {\n    var changes = this._changedParams();\n\n    return !changes ? false : changes.map(function (x) {\n      return x.dynamic;\n    }).reduce(anyTrueR, false);\n  };\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n\n\n  Transition.prototype.ignored = function () {\n    return !!this._ignoredReason();\n  };\n  /** @hidden */\n\n\n  Transition.prototype._ignoredReason = function () {\n    var pending = this.router.globals.transition;\n    var reloadState = this._options.reloadState;\n\n    var same = function (pathA, pathB) {\n      if (pathA.length !== pathB.length) return false;\n      var matching = PathUtils.matching(pathA, pathB);\n      return pathA.length === matching.filter(function (node) {\n        return !reloadState || !node.state.includes[reloadState.name];\n      }).length;\n    };\n\n    var newTC = this.treeChanges();\n    var pendTC = pending && pending.treeChanges();\n    if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return 'SameAsPending';\n    if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return 'SameAsCurrent';\n  };\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internalapi\n   *\n   * @returns a promise for a successful transition.\n   */\n\n\n  Transition.prototype.run = function () {\n    var _this = this;\n\n    var runAllHooks = TransitionHook.runAllHooks; // Gets transition hooks array for the given phase\n\n    var getHooksFor = function (phase) {\n      return _this._hookBuilder.buildHooksForPhase(phase);\n    }; // When the chain is complete, then resolve or reject the deferred\n\n\n    var transitionSuccess = function () {\n      trace.traceSuccess(_this.$to(), _this);\n      _this.success = true;\n\n      _this._deferred.resolve(_this.to());\n\n      runAllHooks(getHooksFor(TransitionHookPhase.SUCCESS));\n    };\n\n    var transitionError = function (reason) {\n      trace.traceError(reason, _this);\n      _this.success = false;\n\n      _this._deferred.reject(reason);\n\n      _this._error = reason;\n      runAllHooks(getHooksFor(TransitionHookPhase.ERROR));\n    };\n\n    var runTransition = function () {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      var allRunHooks = getHooksFor(TransitionHookPhase.RUN);\n\n      var done = function () {\n        return services.$q.when(undefined);\n      };\n\n      return TransitionHook.invokeHooks(allRunHooks, done);\n    };\n\n    var startTransition = function () {\n      var globals = _this.router.globals;\n      globals.lastStartedTransitionId = _this.$id;\n      globals.transition = _this;\n      globals.transitionHistory.enqueue(_this);\n      trace.traceTransitionStart(_this);\n      return services.$q.when(undefined);\n    };\n\n    var allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition).then(runTransition).then(transitionSuccess, transitionError);\n    return this.promise;\n  };\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n\n\n  Transition.prototype.valid = function () {\n    return !this.error() || this.success !== undefined;\n  };\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n\n\n  Transition.prototype.abort = function () {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success)) {\n      this._aborted = true;\n    }\n  };\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.\n   */\n\n\n  Transition.prototype.error = function () {\n    var state = this.$to();\n\n    if (state.self.abstract) {\n      return Rejection.invalid(\"Cannot transition to abstract state '\" + state.name + \"'\");\n    }\n\n    var paramDefs = state.parameters();\n    var values = this.params();\n    var invalidParams = paramDefs.filter(function (param) {\n      return !param.validates(values[param.id]);\n    });\n\n    if (invalidParams.length) {\n      var invalidValues = invalidParams.map(function (param) {\n        return \"[\" + param.id + \":\" + stringify(values[param.id]) + \"]\";\n      }).join(', ');\n      var detail = \"The following parameter values are not valid for state '\" + state.name + \"': \" + invalidValues;\n      return Rejection.invalid(detail);\n    }\n\n    if (this.success === false) return this._error;\n  };\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n\n\n  Transition.prototype.toString = function () {\n    var fromStateOrName = this.from();\n    var toStateOrName = this.to();\n\n    var avoidEmptyHash = function (params) {\n      return params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);\n    }; // (X) means the to state is invalid.\n\n\n    var id = this.$id,\n        from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n        fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))),\n        toValid = this.valid() ? '' : '(X) ',\n        to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n        toParams = stringify(avoidEmptyHash(this.params()));\n    return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n  };\n  /** @hidden */\n\n\n  Transition.diToken = Transition;\n  return Transition;\n}();\n\nexport { Transition };","map":{"version":3,"sources":["@uirouter/core/transition/transition.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module transition */\nimport { trace } from '../common/trace';\nimport { services } from '../common/coreservices';\nimport { stringify } from '../common/strings';\nimport { map, find, extend, mergeR, tail, omit, arrayTuples, unnestR, identity, anyTrueR } from '../common/common';\nimport { isObject, isUndefined } from '../common/predicates';\nimport { prop, propEq, val, not, is } from '../common/hof';\nimport { StateDeclaration, StateOrName } from '../state/interface';\nimport {\n  TransitionOptions,\n  TreeChanges,\n  IHookRegistry,\n  TransitionHookPhase,\n  RegisteredHooks,\n  HookRegOptions,\n  HookMatchCriteria,\n  TransitionStateHookFn,\n  TransitionHookFn,\n} from './interface'; // has or is using\nimport { TransitionHook } from './transitionHook';\nimport { matchState, makeEvent, RegisteredHook } from './hookRegistry';\nimport { HookBuilder } from './hookBuilder';\nimport { PathNode } from '../path/pathNode';\nimport { PathUtils } from '../path/pathUtils';\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ViewConfig } from '../view/interface';\nimport { ResolveContext } from '../resolve/resolveContext';\nimport { UIRouter } from '../router';\nimport { UIInjector } from '../interface';\nimport { RawParams } from '../params/interface';\nimport { ResolvableLiteral } from '../resolve/interface';\nimport { Rejection } from './rejectFactory';\nimport { applyPairs, flattenR, uniqR } from '../common';\n\n/** @hidden */\nconst stateSelf: (_state: StateObject) => StateDeclaration = prop('self');\n\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nexport class Transition implements IHookRegistry {\n  /** @hidden */\n  static diToken = Transition;\n\n  /**\n   * A unique identifier for the transition.\n   *\n   * This is an auto incrementing integer, starting from `0`.\n   */\n  $id: number;\n\n  /**\n   * A reference to the [[UIRouter]] instance\n   *\n   * This reference can be used to access the router services, such as the [[StateService]]\n   */\n  router: UIRouter;\n\n  /** @hidden */\n  private _deferred = services.$q.defer();\n  /**\n   * This promise is resolved or rejected based on the outcome of the Transition.\n   *\n   * When the transition is successful, the promise is resolved\n   * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n   */\n  promise: Promise<any> = this._deferred.promise;\n  /**\n   * A boolean which indicates if the transition was successful\n   *\n   * After a successful transition, this value is set to true.\n   * After an unsuccessful transition, this value is set to false.\n   *\n   * The value will be undefined if the transition is not complete\n   */\n  success: boolean;\n  /** @hidden */\n  _aborted: boolean;\n  /** @hidden */\n  private _error: Rejection;\n\n  /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n  _registeredHooks: RegisteredHooks = {};\n\n  /** @hidden */\n  private _options: TransitionOptions;\n  /** @hidden */\n  private _treeChanges: TreeChanges;\n  /** @hidden */\n  private _targetState: TargetState;\n  /** @hidden */\n  private _hookBuilder = new HookBuilder(this);\n\n  /** @hidden */\n  onBefore(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onStart(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onExit(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onRetain(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onEnter(criteria: HookMatchCriteria, callback: TransitionStateHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onFinish(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onSuccess(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n  /** @inheritdoc */\n  onError(criteria: HookMatchCriteria, callback: TransitionHookFn, options?: HookRegOptions): Function {\n    return;\n  }\n\n  /** @hidden\n   * Creates the transition-level hook registration functions\n   * (which can then be used to register hooks)\n   */\n  private createTransitionHookRegFns() {\n    this.router.transitionService._pluginapi\n      ._getEvents()\n      .filter(type => type.hookPhase !== TransitionHookPhase.CREATE)\n      .forEach(type => makeEvent(this, this.router.transitionService, type));\n  }\n\n  /** @internalapi */\n  getHooks(hookName: string): RegisteredHook[] {\n    return this._registeredHooks[hookName];\n  }\n\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @internalapi\n   *\n   * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param router The [[UIRouter]] instance\n   */\n  constructor(fromPath: PathNode[], targetState: TargetState, router: UIRouter) {\n    this.router = router;\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    }\n\n    // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n    this._options = extend({ current: val(this) }, targetState.options());\n    this.$id = router.transitionService._transitionCount++;\n    const toPath = PathUtils.buildToPath(fromPath, targetState);\n    this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n    this.createTransitionHookRegFns();\n\n    const onCreateHooks = this._hookBuilder.buildHooksForPhase(TransitionHookPhase.CREATE);\n    TransitionHook.invokeHooks(onCreateHooks, () => null);\n\n    this.applyViewConfigs(router);\n  }\n\n  private applyViewConfigs(router: UIRouter) {\n    const enteringStates = this._treeChanges.entering.map(node => node.state);\n    PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n  }\n\n  /**\n   * @internalapi\n   *\n   * @returns the internal from [State] object\n   */\n  $from() {\n    return tail(this._treeChanges.from).state;\n  }\n\n  /**\n   * @internalapi\n   *\n   * @returns the internal to [State] object\n   */\n  $to() {\n    return tail(this._treeChanges.to).state;\n  }\n\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns The state declaration object for the Transition's (\"from state\").\n   */\n  from(): StateDeclaration {\n    return this.$from().self;\n  }\n\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns The state declaration object for the Transition's target state (\"to state\").\n   */\n  to(): StateDeclaration {\n    return this.$to().self;\n  }\n\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns the [[TargetState]] of this Transition\n   */\n  targetState() {\n    return this._targetState;\n  }\n\n  /**\n   * Determines whether two transitions are equivalent.\n   * @deprecated\n   */\n  is(compare: Transition | { to?: any; from?: any }): boolean {\n    if (compare instanceof Transition) {\n      // TODO: Also compare parameters\n      return this.is({ to: compare.$to().name, from: compare.$from().name });\n    }\n    return !(\n      (compare.to && !matchState(this.$to(), compare.to, this)) ||\n      (compare.from && !matchState(this.$from(), compare.from, this))\n    );\n  }\n\n  /**\n   * Gets transition parameter values\n   *\n   * Returns the parameter values for a transition as key/value pairs.\n   * This object is immutable.\n   *\n   * By default, returns the new parameter values (for the \"to state\").\n   *\n   * #### Example:\n   * ```js\n   * var toParams = transition.params();\n   * ```\n   *\n   * To return the previous parameter values,  supply `'from'` as the `pathname` argument.\n   *\n   * #### Example:\n   * ```js\n   * var fromParams = transition.params('from');\n   * ```\n   *\n   * @param pathname the name of the treeChanges path to get parameter values for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   *\n   * @returns transition parameter values for the desired path.\n   */\n  params(pathname?: string): { [paramName: string]: any };\n  params<T>(pathname?: string): T;\n  params(pathname = 'to') {\n    return Object.freeze(this._treeChanges[pathname].map(prop('paramValues')).reduce(mergeR, {}));\n  }\n\n  /**\n   * Gets the new values of any parameters that changed during this transition.\n   *\n   * Returns any parameter values that have changed during a transition, as key/value pairs.\n   *\n   * - Any parameter values that have changed will be present on the returned object reflecting the new value.\n   * - Any parameters that *not* have changed will not be present on the returned object.\n   * - Any new parameters that weren't present in the \"from\" state, but are now present in the \"to\" state will be present on the returned object.\n   * - Any previous parameters that are no longer present (because the \"to\" state doesn't have them) will be included with a value of `undefined`.\n   *\n   * The returned object is immutable.\n   *\n   * #### Examples:\n   *\n   * Given:\n   * ```js\n   * var stateA = { name: 'stateA', url: '/stateA/:param1/param2' }\n   * var stateB = { name: 'stateB', url: '/stateB/:param3' }\n   * var stateC = { name: 'stateB.nest', url: '/nest/:param4' }\n   * ```\n   *\n   * #### Example 1\n   *\n   * From `/stateA/abc/def` to `/stateA/abc/xyz`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param2: 'xyz' }\n   * ```\n   *\n   * The value of `param2` changed to `xyz`.\n   * The value of `param1` stayed the same so its value is not present.\n   *\n   * #### Example 2\n   *\n   * From `/stateA/abc/def` to `/stateB/123`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param1: undefined, param2: undefined, param3: '123' }\n   * ```\n   *\n   * The value `param3` is present because it is a new param.\n   * Both `param1` and `param2` are no longer present so their value is undefined.\n   *\n   * #### Example 3\n   *\n   * From `/stateB/123` to `/stateB/123/nest/456`\n   *\n   * ```js\n   * var changed = transition.paramsChanged()\n   * // changed is { param4: '456' }\n   * ```\n   *\n   * The value `param4` is present because it is a new param.\n   * The value of `param3` did not change, so its value is not present.\n   *\n   * @returns an immutable object with changed parameter keys/values.\n   */\n  paramsChanged(): { [paramName: string]: any };\n  paramsChanged<T>(): T;\n  paramsChanged() {\n    const fromParams = this.params('from');\n    const toParams = this.params('to');\n\n    // All the parameters declared on both the \"to\" and \"from\" paths\n    const allParamDescriptors: Param[] = []\n      .concat(this._treeChanges.to)\n      .concat(this._treeChanges.from)\n      .map(pathNode => pathNode.paramSchema)\n      .reduce(flattenR, [])\n      .reduce(uniqR, []);\n\n    const changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);\n\n    return changedParamDescriptors.reduce((changedValues, descriptor) => {\n      changedValues[descriptor.id] = toParams[descriptor.id];\n      return changedValues;\n    }, {});\n  }\n\n  /**\n   * Creates a [[UIInjector]] Dependency Injector\n   *\n   * Returns a Dependency Injector for the Transition's target state (to state).\n   * The injector provides resolve values which the target state has access to.\n   *\n   * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n   *\n   * #### Example:\n   * ```js\n   * .onEnter({ entering: 'myState' }, trans => {\n   *   var myResolveValue = trans.injector().get('myResolve');\n   *   // Inject a global service from the global/native injector (if it exists)\n   *   var MyService = trans.injector().get('MyService');\n   * })\n   * ```\n   *\n   * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n   * You can use [[UIInjector.getAsync]] to get a promise for the data.\n   * #### Example:\n   * ```js\n   * .onBefore({}, trans => {\n   *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n   *     return myResolveValue !== 'ABORT';\n   *   });\n   * });\n   * ```\n   *\n   * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n   * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n   * #### Example:\n   * ```js\n   * .onEnter({ to: 'foo.bar' }, trans => {\n   *   // returns result of `foo` state's `myResolve` resolve\n   *   // even though `foo.bar` also has a `myResolve` resolve\n   *   var fooData = trans.injector('foo').get('myResolve');\n   * });\n   * ```\n   *\n   * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n   * The resolve data from the `from` path will be returned.\n   * #### Example:\n   * ```js\n   * .onExit({ exiting: 'foo.bar' }, trans => {\n   *   // Gets the resolve value of `myResolve` from the state being exited\n   *   var fooData = trans.injector(null, 'from').get('myResolve');\n   * });\n   * ```\n   *\n   *\n   * @param state Limits the resolves provided to only the resolves the provided state has access to.\n   * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n   *\n   * @returns a [[UIInjector]]\n   */\n  injector(state?: StateOrName, pathName = 'to'): UIInjector {\n    let path: PathNode[] = this._treeChanges[pathName];\n    if (state) path = PathUtils.subPath(path, node => node.state === state || node.state.name === state);\n    return new ResolveContext(path).injector();\n  }\n\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n  getResolveTokens(pathname = 'to'): any[] {\n    return new ResolveContext(this._treeChanges[pathname]).getTokens();\n  }\n\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * Allows a transition hook to dynamically add a Resolvable to this Transition.\n   *\n   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n   *\n   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n   * If no `state` is provided then the root state is used.\n   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n   *\n   * The `state` argument also scopes the resolved data.\n   * The resolved data is available from the injector for that `state` and any children states.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n  addResolvable(resolvable: Resolvable | ResolvableLiteral, state: StateOrName = ''): void {\n    resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);\n\n    const stateName: string = typeof state === 'string' ? state : state.name;\n    const topath = this._treeChanges.to;\n    const targetNode = find(topath, node => node.state.name === stateName);\n    const resolveContext: ResolveContext = new ResolveContext(topath);\n    resolveContext.addResolvables([resolvable as Resolvable], targetNode.state);\n  }\n\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns The previous Transition, or null if this Transition is not the result of a redirection\n   */\n  redirectedFrom(): Transition {\n    return this._options.redirectedFrom || null;\n  }\n\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns The original Transition that started a redirect chain\n   */\n  originalTransition(): Transition {\n    const rf = this.redirectedFrom();\n    return (rf && rf.originalTransition()) || this;\n  }\n\n  /**\n   * Get the transition options\n   *\n   * @returns the options for this Transition.\n   */\n  options(): TransitionOptions {\n    return this._options;\n  }\n\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n  entering(): StateDeclaration[] {\n    return map(this._treeChanges.entering, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Gets the states being exited.\n   *\n   * @returns an array of states that will be exited during this transition.\n   */\n  exiting(): StateDeclaration[] {\n    return map(this._treeChanges.exiting, prop('state'))\n      .map(stateSelf)\n      .reverse();\n  }\n\n  /**\n   * Gets the states being retained.\n   *\n   * @returns an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n  retained(): StateDeclaration[] {\n    return map(this._treeChanges.retained, prop('state')).map(stateSelf);\n  }\n\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns a list of ViewConfig objects for the given path.\n   */\n  views(pathname = 'entering', state?: StateObject): ViewConfig[] {\n    let path = this._treeChanges[pathname];\n    path = !state ? path : path.filter(propEq('state', state));\n    return path\n      .map(prop('views'))\n      .filter(identity)\n      .reduce(unnestR, []);\n  }\n\n  /**\n   * Return the transition's tree changes\n   *\n   * A transition goes from one state/parameters to another state/parameters.\n   * During a transition, states are entered and/or exited.\n   *\n   * This function returns various branches (paths) which represent the changes to the\n   * active state tree that are caused by the transition.\n   *\n   * @param pathname The name of the tree changes path to get:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   */\n  treeChanges(pathname: string): PathNode[];\n  treeChanges(): TreeChanges;\n  treeChanges(pathname?: string) {\n    return pathname ? this._treeChanges[pathname] : this._treeChanges;\n  }\n\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @internalapi\n   *\n   * @returns Returns a new [[Transition]] instance.\n   */\n  redirect(targetState: TargetState): Transition {\n    let redirects = 1,\n      trans: Transition = this;\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((trans = trans.redirectedFrom()) != null) {\n      if (++redirects > 20) throw new Error(`Too many consecutive Transition redirects (20+)`);\n    }\n\n    const redirectOpts: TransitionOptions = { redirectedFrom: this, source: 'redirect' };\n    // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n    if (this.options().source === 'url' && targetState.options().location !== false) {\n      redirectOpts.location = 'replace';\n    }\n\n    const newOptions = extend({}, this.options(), targetState.options(), redirectOpts);\n    targetState = targetState.withOptions(newOptions, true);\n\n    const newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n    const originalEnteringNodes = this._treeChanges.entering;\n    const redirectEnteringNodes = newTransition._treeChanges.entering;\n\n    // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n\n    const nodeIsReloading = (reloadState: StateObject) => (node: PathNode) => {\n      return reloadState && node.state.includes[reloadState.name];\n    };\n\n    // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n    const matchingEnteringNodes: PathNode[] = PathUtils.matching(\n      redirectEnteringNodes,\n      originalEnteringNodes,\n      PathUtils.nonDynamicParams\n    ).filter(not(nodeIsReloading(targetState.options().reloadState)));\n\n    // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n    matchingEnteringNodes.forEach((node, idx) => {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n\n    return newTransition;\n  }\n\n  /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n  private _changedParams(): Param[] {\n    const tc = this._treeChanges;\n\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n    if (this._options.reload) return undefined;\n    // If any states are exiting or entering\n    if (tc.exiting.length || tc.entering.length) return undefined;\n    // If to/from path lengths differ\n    if (tc.to.length !== tc.from.length) return undefined;\n    // If the to/from paths are different\n    const pathsDiffer: boolean = arrayTuples(tc.to, tc.from)\n      .map(tuple => tuple[0].state !== tuple[1].state)\n      .reduce(anyTrueR, false);\n    if (pathsDiffer) return undefined;\n\n    // Find any parameter values that differ\n    const nodeSchemas: Param[][] = tc.to.map((node: PathNode) => node.paramSchema);\n    const [toValues, fromValues] = [tc.to, tc.from].map(path => path.map(x => x.paramValues));\n    const tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n\n    return tuples.map(([schema, toVals, fromVals]) => Param.changed(schema, toVals, fromVals)).reduce(unnestR, []);\n  }\n\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns true if the Transition is dynamic\n   */\n  dynamic(): boolean {\n    const changes = this._changedParams();\n    return !changes ? false : changes.map(x => x.dynamic).reduce(anyTrueR, false);\n  }\n\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n  ignored(): boolean {\n    return !!this._ignoredReason();\n  }\n\n  /** @hidden */\n  _ignoredReason(): 'SameAsCurrent' | 'SameAsPending' | undefined {\n    const pending = this.router.globals.transition;\n    const reloadState = this._options.reloadState;\n\n    const same = (pathA, pathB) => {\n      if (pathA.length !== pathB.length) return false;\n      const matching = PathUtils.matching(pathA, pathB);\n      return pathA.length === matching.filter(node => !reloadState || !node.state.includes[reloadState.name]).length;\n    };\n\n    const newTC = this.treeChanges();\n    const pendTC = pending && pending.treeChanges();\n\n    if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return 'SameAsPending';\n    if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return 'SameAsCurrent';\n  }\n\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internalapi\n   *\n   * @returns a promise for a successful transition.\n   */\n  run(): Promise<any> {\n    const runAllHooks = TransitionHook.runAllHooks;\n\n    // Gets transition hooks array for the given phase\n    const getHooksFor = (phase: TransitionHookPhase) => this._hookBuilder.buildHooksForPhase(phase);\n\n    // When the chain is complete, then resolve or reject the deferred\n    const transitionSuccess = () => {\n      trace.traceSuccess(this.$to(), this);\n      this.success = true;\n      this._deferred.resolve(this.to());\n      runAllHooks(getHooksFor(TransitionHookPhase.SUCCESS));\n    };\n\n    const transitionError = (reason: Rejection) => {\n      trace.traceError(reason, this);\n      this.success = false;\n      this._deferred.reject(reason);\n      this._error = reason;\n      runAllHooks(getHooksFor(TransitionHookPhase.ERROR));\n    };\n\n    const runTransition = () => {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      const allRunHooks = getHooksFor(TransitionHookPhase.RUN);\n      const done = () => services.$q.when(undefined);\n      return TransitionHook.invokeHooks(allRunHooks, done);\n    };\n\n    const startTransition = () => {\n      const globals = this.router.globals;\n\n      globals.lastStartedTransitionId = this.$id;\n      globals.transition = this;\n      globals.transitionHistory.enqueue(this);\n\n      trace.traceTransitionStart(this);\n\n      return services.$q.when(undefined);\n    };\n\n    const allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n      .then(runTransition)\n      .then(transitionSuccess, transitionError);\n\n    return this.promise;\n  }\n\n  /** Checks if this transition is currently active/running. */\n  isActive = () => this.router.globals.transition === this;\n\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n  valid() {\n    return !this.error() || this.success !== undefined;\n  }\n\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n  abort() {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success)) {\n      this._aborted = true;\n    }\n  }\n\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.\n   */\n  error(): Rejection {\n    const state: StateObject = this.$to();\n\n    if (state.self.abstract) {\n      return Rejection.invalid(`Cannot transition to abstract state '${state.name}'`);\n    }\n\n    const paramDefs = state.parameters();\n    const values = this.params();\n    const invalidParams = paramDefs.filter(param => !param.validates(values[param.id]));\n\n    if (invalidParams.length) {\n      const invalidValues = invalidParams.map(param => `[${param.id}:${stringify(values[param.id])}]`).join(', ');\n      const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;\n      return Rejection.invalid(detail);\n    }\n\n    if (this.success === false) return this._error;\n  }\n\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n  toString() {\n    const fromStateOrName = this.from();\n    const toStateOrName = this.to();\n\n    const avoidEmptyHash = (params: RawParams) =>\n      params['#'] !== null && params['#'] !== undefined ? params : omit(params, ['#']);\n\n    // (X) means the to state is invalid.\n    const id = this.$id,\n      from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n      fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop('paramValues')).reduce(mergeR, {}))),\n      toValid = this.valid() ? '' : '(X) ',\n      to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n      toParams = stringify(avoidEmptyHash(this.params()));\n\n    return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}