{"ast":null,"code":"/** @packageDocumentation @internalapi @module path */\nimport { extend, find, pick, omit, tail, mergeR, values, unnestR, inArray, arrayTuples } from '../common/common';\nimport { prop, propEq } from '../common/hof';\nimport { TargetState } from '../state/targetState';\nimport { PathNode } from './pathNode';\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\n\nvar PathUtils =\n/** @class */\nfunction () {\n  function PathUtils() {}\n  /** Given a PathNode[], create an TargetState */\n\n\n  PathUtils.makeTargetState = function (registry, path) {\n    var state = tail(path).state;\n    return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});\n  };\n\n  PathUtils.buildPath = function (targetState) {\n    var toParams = targetState.params();\n    return targetState.$state().path.map(function (state) {\n      return new PathNode(state).applyRawParams(toParams);\n    });\n  };\n  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\n\n  PathUtils.buildToPath = function (fromPath, targetState) {\n    var toPath = PathUtils.buildPath(targetState);\n\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n    }\n\n    return toPath;\n  };\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   */\n\n\n  PathUtils.applyViewConfigs = function ($view, path, states) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path.filter(function (node) {\n      return inArray(states, node.state);\n    }).forEach(function (node) {\n      var viewDecls = values(node.state.views || {});\n      var subPath = PathUtils.subPath(path, function (n) {\n        return n === node;\n      });\n      var viewConfigs = viewDecls.map(function (view) {\n        return $view.createViewConfig(subPath, view);\n      });\n      node.views = viewConfigs.reduce(unnestR, []);\n    });\n  };\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   */\n\n\n  PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n    if (toKeys === void 0) {\n      toKeys = [];\n    }\n\n    function nodeParamVals(path, state) {\n      var node = find(path, propEq('state', state));\n      return extend({}, node && node.paramValues);\n    }\n\n    var noInherit = fromPath.map(function (node) {\n      return node.paramSchema;\n    }).reduce(unnestR, []).filter(function (param) {\n      return !param.inherit;\n    }).map(prop('id'));\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     */\n\n    function makeInheritedParamsNode(toNode) {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      var toParamVals = extend({}, toNode && toNode.paramValues); // limited to only those keys found in toParams\n\n      var incomingParamVals = pick(toParamVals, toKeys);\n      toParamVals = omit(toParamVals, toKeys);\n      var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit); // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\n      var ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    } // The param keys specified by the incoming toParams\n\n\n    return toPath.map(makeInheritedParamsNode);\n  };\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   */\n\n\n  PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n    var max = Math.min(fromPath.length, toPath.length);\n    var keep = 0;\n\n    var nodesMatch = function (node1, node2) {\n      return node1.equals(node2, PathUtils.nonDynamicParams);\n    };\n\n    while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n      keep++;\n    }\n    /** Given a retained node, return a new node which uses the to node's param values */\n\n\n    function applyToParams(retainedNode, idx) {\n      var cloned = retainedNode.clone();\n      cloned.paramValues = toPath[idx].paramValues;\n      return cloned;\n    }\n\n    var from, retained, exiting, entering, to;\n    from = fromPath;\n    retained = from.slice(0, keep);\n    exiting = from.slice(keep); // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\n    var retainedWithToParams = retained.map(applyToParams);\n    entering = toPath.slice(keep);\n    to = retainedWithToParams.concat(entering);\n    return {\n      from: from,\n      to: to,\n      retained: retained,\n      retainedWithToParams: retainedWithToParams,\n      exiting: exiting,\n      entering: entering\n    };\n  };\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param pathA the first path\n   * @param pathB the second path\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   *\n   * @returns an array of PathNodes from the first path which match the nodes in the second path\n   */\n\n\n  PathUtils.matching = function (pathA, pathB, paramsFn) {\n    var done = false;\n    var tuples = arrayTuples(pathA, pathB);\n    return tuples.reduce(function (matching, _a) {\n      var nodeA = _a[0],\n          nodeB = _a[1];\n      done = done || !nodeA.equals(nodeB, paramsFn);\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  };\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param pathA\n   * @param pathB\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n\n\n  PathUtils.equals = function (pathA, pathB, paramsFn) {\n    return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n  };\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   *\n   * @param path a path of [[PathNode]]s\n   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns a subpath up to the matching node, or undefined if no match is found\n   */\n\n\n  PathUtils.subPath = function (path, predicate) {\n    var node = find(path, predicate);\n    var elementIdx = path.indexOf(node);\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  };\n\n  PathUtils.nonDynamicParams = function (node) {\n    return node.state.parameters({\n      inherit: false\n    }).filter(function (param) {\n      return !param.dynamic;\n    });\n  };\n  /** Gets the raw parameter values from a path */\n\n\n  PathUtils.paramValues = function (path) {\n    return path.reduce(function (acc, node) {\n      return extend(acc, node.paramValues);\n    }, {});\n  };\n\n  return PathUtils;\n}();\n\nexport { PathUtils };","map":{"version":3,"sources":["@uirouter/core/path/pathUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @internalapi @module path */\n\nimport {\n  extend,\n  find,\n  pick,\n  omit,\n  tail,\n  mergeR,\n  values,\n  unnestR,\n  Predicate,\n  inArray,\n  arrayTuples,\n} from '../common/common';\nimport { prop, propEq, not } from '../common/hof';\n\nimport { RawParams } from '../params/interface';\nimport { TreeChanges } from '../transition/interface';\nimport { ViewConfig } from '../view/interface';\nimport { _ViewDeclaration } from '../state/interface';\n\nimport { StateObject } from '../state/stateObject';\nimport { TargetState } from '../state/targetState';\nimport { GetParamsFn, PathNode } from './pathNode';\nimport { ViewService } from '../view/view';\nimport { Param } from '../params/param';\nimport { StateRegistry } from '../state';\n\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nexport class PathUtils {\n  /** Given a PathNode[], create an TargetState */\n  static makeTargetState(registry: StateRegistry, path: PathNode[]): TargetState {\n    const state = tail(path).state;\n    return new TargetState(registry, state, path.map(prop('paramValues')).reduce(mergeR, {}), {});\n  }\n\n  static buildPath(targetState: TargetState) {\n    const toParams = targetState.params();\n    return targetState.$state().path.map(state => new PathNode(state).applyRawParams(toParams));\n  }\n\n  /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n  static buildToPath(fromPath: PathNode[], targetState: TargetState): PathNode[] {\n    const toPath: PathNode[] = PathUtils.buildPath(targetState);\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n    }\n    return toPath;\n  }\n\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   */\n  static applyViewConfigs($view: ViewService, path: PathNode[], states: StateObject[]) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path\n      .filter(node => inArray(states, node.state))\n      .forEach(node => {\n        const viewDecls: _ViewDeclaration[] = values(node.state.views || {});\n        const subPath = PathUtils.subPath(path, n => n === node);\n        const viewConfigs: ViewConfig[][] = viewDecls.map(view => $view.createViewConfig(subPath, view));\n        node.views = viewConfigs.reduce(unnestR, []);\n      });\n  }\n\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   */\n  static inheritParams(fromPath: PathNode[], toPath: PathNode[], toKeys: string[] = []): PathNode[] {\n    function nodeParamVals(path: PathNode[], state: StateObject): RawParams {\n      const node: PathNode = find(path, propEq('state', state));\n      return extend({}, node && node.paramValues);\n    }\n\n    const noInherit = fromPath\n      .map(node => node.paramSchema)\n      .reduce(unnestR, [])\n      .filter(param => !param.inherit)\n      .map(prop('id'));\n\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     */\n    function makeInheritedParamsNode(toNode: PathNode): PathNode {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      let toParamVals = extend({}, toNode && toNode.paramValues);\n      // limited to only those keys found in toParams\n      const incomingParamVals = pick(toParamVals, toKeys);\n      toParamVals = omit(toParamVals, toKeys);\n      const fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n      // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n      const ownParamVals: RawParams = extend(toParamVals, fromParamVals, incomingParamVals);\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    }\n\n    // The param keys specified by the incoming toParams\n    return <PathNode[]>toPath.map(makeInheritedParamsNode);\n  }\n\n  static nonDynamicParams = (node: PathNode): Param[] =>\n    node.state.parameters({ inherit: false }).filter(param => !param.dynamic);\n\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   */\n  static treeChanges(fromPath: PathNode[], toPath: PathNode[], reloadState: StateObject): TreeChanges {\n    const max = Math.min(fromPath.length, toPath.length);\n    let keep = 0;\n\n    const nodesMatch = (node1: PathNode, node2: PathNode) => node1.equals(node2, PathUtils.nonDynamicParams);\n\n    while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n      keep++;\n    }\n\n    /** Given a retained node, return a new node which uses the to node's param values */\n    function applyToParams(retainedNode: PathNode, idx: number): PathNode {\n      const cloned = retainedNode.clone();\n      cloned.paramValues = toPath[idx].paramValues;\n      return cloned;\n    }\n\n    let from: PathNode[], retained: PathNode[], exiting: PathNode[], entering: PathNode[], to: PathNode[];\n\n    from = fromPath;\n    retained = from.slice(0, keep);\n    exiting = from.slice(keep);\n\n    // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n    const retainedWithToParams = retained.map(applyToParams);\n    entering = toPath.slice(keep);\n    to = retainedWithToParams.concat(entering);\n\n    return { from, to, retained, retainedWithToParams, exiting, entering };\n  }\n\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param pathA the first path\n   * @param pathB the second path\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   *\n   * @returns an array of PathNodes from the first path which match the nodes in the second path\n   */\n  static matching(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): PathNode[] {\n    let done = false;\n    const tuples: PathNode[][] = arrayTuples(pathA, pathB);\n    return tuples.reduce((matching, [nodeA, nodeB]) => {\n      done = done || !nodeA.equals(nodeB, paramsFn);\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  }\n\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param pathA\n   * @param pathB\n   * @param paramsFn a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n  static equals(pathA: PathNode[], pathB: PathNode[], paramsFn?: GetParamsFn): boolean {\n    return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n  }\n\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   *\n   * @param path a path of [[PathNode]]s\n   * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns a subpath up to the matching node, or undefined if no match is found\n   */\n  static subPath(path: PathNode[], predicate: Predicate<PathNode>): PathNode[] {\n    const node = find(path, predicate);\n    const elementIdx = path.indexOf(node);\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  }\n\n  /** Gets the raw parameter values from a path */\n  static paramValues = (path: PathNode[]) => path.reduce((acc, node) => extend(acc, node.paramValues), {});\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}