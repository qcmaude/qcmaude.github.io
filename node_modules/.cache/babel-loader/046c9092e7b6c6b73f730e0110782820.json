{"ast":null,"code":"import { services } from '../common/coreservices';\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\n\nvar lazyLoadHook = function (transition) {\n  var router = transition.router;\n\n  function retryTransition() {\n    if (transition.originalTransition().options().source !== 'url') {\n      // The original transition was not triggered via url sync\n      // The lazy state should be loaded now, so re-try the original transition\n      var orig = transition.targetState();\n      return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n    } // The original transition was triggered via url sync\n    // Run the URL rules and find the best match\n\n\n    var $url = router.urlService;\n    var result = $url.match($url.parts());\n    var rule = result && result.rule; // If the best match is a state, redirect the transition (instead\n    // of calling sync() which supersedes the current transition)\n\n    if (rule && rule.type === 'STATE') {\n      var state = rule.state;\n      var params = result.match;\n      return router.stateService.target(state, params, transition.options());\n    } // No matching state found, so let .sync() choose the best non-state match/otherwise\n\n\n    router.urlService.sync();\n  }\n\n  var promises = transition.entering().filter(function (state) {\n    return !!state.$$state().lazyLoad;\n  }).map(function (state) {\n    return lazyLoadState(transition, state);\n  });\n  return services.$q.all(promises).then(retryTransition);\n};\n\nexport var registerLazyLoadHook = function (transitionService) {\n  return transitionService.onBefore({\n    entering: function (state) {\n      return !!state.lazyLoad;\n    }\n  }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\n\nexport function lazyLoadState(transition, state) {\n  var lazyLoadFn = state.$$state().lazyLoad; // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\n  var promise = lazyLoadFn['_promise'];\n\n  if (!promise) {\n    var success = function (result) {\n      delete state.lazyLoad;\n      delete state.$$state().lazyLoad;\n      delete lazyLoadFn['_promise'];\n      return result;\n    };\n\n    var error = function (err) {\n      delete lazyLoadFn['_promise'];\n      return services.$q.reject(err);\n    };\n\n    promise = lazyLoadFn['_promise'] = services.$q.when(lazyLoadFn(transition, state)).then(updateStateRegistry).then(success, error);\n  }\n  /** Register any lazy loaded state definitions */\n\n\n  function updateStateRegistry(result) {\n    if (result && Array.isArray(result.states)) {\n      result.states.forEach(function (_state) {\n        return transition.router.stateRegistry.register(_state);\n      });\n    }\n\n    return result;\n  }\n\n  return promise;\n}","map":{"version":3,"sources":["@uirouter/core/hooks/lazyLoad.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @internalapi @module hooks */\nimport { Transition } from '../transition/transition';\nimport { TransitionService } from '../transition/transitionService';\nimport { TransitionHookFn } from '../transition/interface';\nimport { StateDeclaration, LazyLoadResult } from '../state/interface';\nimport { services } from '../common/coreservices';\nimport { StateRule } from '../url/interface';\n\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nconst lazyLoadHook: TransitionHookFn = (transition: Transition) => {\n  const router = transition.router;\n\n  function retryTransition() {\n    if (transition.originalTransition().options().source !== 'url') {\n      // The original transition was not triggered via url sync\n      // The lazy state should be loaded now, so re-try the original transition\n      const orig = transition.targetState();\n      return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n    }\n\n    // The original transition was triggered via url sync\n    // Run the URL rules and find the best match\n    const $url = router.urlService;\n    const result = $url.match($url.parts());\n    const rule = result && result.rule;\n\n    // If the best match is a state, redirect the transition (instead\n    // of calling sync() which supersedes the current transition)\n    if (rule && rule.type === 'STATE') {\n      const state = (rule as StateRule).state;\n      const params = result.match;\n      return router.stateService.target(state, params, transition.options());\n    }\n\n    // No matching state found, so let .sync() choose the best non-state match/otherwise\n    router.urlService.sync();\n  }\n\n  const promises = transition\n    .entering()\n    .filter(state => !!state.$$state().lazyLoad)\n    .map(state => lazyLoadState(transition, state));\n\n  return services.$q.all(promises).then(retryTransition);\n};\n\nexport const registerLazyLoadHook = (transitionService: TransitionService) =>\n  transitionService.onBefore({ entering: state => !!state.lazyLoad }, lazyLoadHook);\n\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nexport function lazyLoadState(transition: Transition, state: StateDeclaration): Promise<LazyLoadResult> {\n  const lazyLoadFn = state.$$state().lazyLoad;\n\n  // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n  let promise = lazyLoadFn['_promise'];\n  if (!promise) {\n    const success = result => {\n      delete state.lazyLoad;\n      delete state.$$state().lazyLoad;\n      delete lazyLoadFn['_promise'];\n      return result;\n    };\n\n    const error = err => {\n      delete lazyLoadFn['_promise'];\n      return services.$q.reject(err);\n    };\n\n    promise = lazyLoadFn['_promise'] = services.$q\n      .when(lazyLoadFn(transition, state))\n      .then(updateStateRegistry)\n      .then(success, error);\n  }\n\n  /** Register any lazy loaded state definitions */\n  function updateStateRegistry(result: LazyLoadResult) {\n    if (result && Array.isArray(result.states)) {\n      result.states.forEach(_state => transition.router.stateRegistry.register(_state));\n    }\n    return result;\n  }\n\n  return promise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}