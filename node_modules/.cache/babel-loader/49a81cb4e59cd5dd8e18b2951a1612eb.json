{"ast":null,"code":"/** @packageDocumentation @internalapi @module path */\nimport { extend, applyPairs, find } from '../common/common';\nimport { propEq } from '../common/hof';\nimport { Param } from '../params/param';\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\n\nvar PathNode =\n/** @class */\nfunction () {\n  function PathNode(stateOrNode) {\n    if (stateOrNode instanceof PathNode) {\n      var node = stateOrNode;\n      this.state = node.state;\n      this.paramSchema = node.paramSchema.slice();\n      this.paramValues = extend({}, node.paramValues);\n      this.resolvables = node.resolvables.slice();\n      this.views = node.views && node.views.slice();\n    } else {\n      var state = stateOrNode;\n      this.state = state;\n      this.paramSchema = state.parameters({\n        inherit: false\n      });\n      this.paramValues = {};\n      this.resolvables = state.resolvables.map(function (res) {\n        return res.clone();\n      });\n    }\n  }\n\n  PathNode.prototype.clone = function () {\n    return new PathNode(this);\n  };\n  /** Sets [[paramValues]] for the node, from the values of an object hash */\n\n\n  PathNode.prototype.applyRawParams = function (params) {\n    var getParamVal = function (paramDef) {\n      return [paramDef.id, paramDef.value(params[paramDef.id])];\n    };\n\n    this.paramValues = this.paramSchema.reduce(function (memo, pDef) {\n      return applyPairs(memo, getParamVal(pDef));\n    }, {});\n    return this;\n  };\n  /** Gets a specific [[Param]] metadata that belongs to the node */\n\n\n  PathNode.prototype.parameter = function (name) {\n    return find(this.paramSchema, propEq('id', name));\n  };\n  /**\n   * @returns true if the state and parameter values for another PathNode are\n   * equal to the state and param values for this PathNode\n   */\n\n\n  PathNode.prototype.equals = function (node, paramsFn) {\n    var diff = this.diff(node, paramsFn);\n    return diff && diff.length === 0;\n  };\n  /**\n   * Finds Params with different parameter values on another PathNode.\n   *\n   * Given another node (of the same state), finds the parameter values which differ.\n   * Returns the [[Param]] (schema objects) whose parameter values differ.\n   *\n   * Given another node for a different state, returns `false`\n   *\n   * @param node The node to compare to\n   * @param paramsFn A function that returns which parameters should be compared.\n   * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n   */\n\n\n  PathNode.prototype.diff = function (node, paramsFn) {\n    if (this.state !== node.state) return false;\n    var params = paramsFn ? paramsFn(this) : this.paramSchema;\n    return Param.changed(params, this.paramValues, node.paramValues);\n  };\n  /**\n   * Returns a clone of the PathNode\n   * @deprecated use instance method `node.clone()`\n   */\n\n\n  PathNode.clone = function (node) {\n    return node.clone();\n  };\n\n  return PathNode;\n}();\n\nexport { PathNode };","map":{"version":3,"sources":["@uirouter/core/path/pathNode.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @internalapi @module path */\nimport { extend, applyPairs, find, allTrueR, pairs, arrayTuples } from '../common/common';\nimport { propEq } from '../common/hof';\nimport { StateObject } from '../state/stateObject';\nimport { RawParams } from '../params/interface';\nimport { Param } from '../params/param';\nimport { Resolvable } from '../resolve/resolvable';\nimport { ViewConfig } from '../view/interface';\n\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nexport class PathNode {\n  /** The state being entered, exited, or retained */\n  public state: StateObject;\n  /** The parameters declared on the state */\n  public paramSchema: Param[];\n  /** The parameter values that belong to the state */\n  public paramValues: { [key: string]: any };\n  /** The individual (stateful) resolvable objects that belong to the state */\n  public resolvables: Resolvable[];\n  /** The state's declared view configuration objects */\n  public views: ViewConfig[];\n\n  /**\n   * Returns a clone of the PathNode\n   * @deprecated use instance method `node.clone()`\n   */\n  static clone = (node: PathNode) => node.clone();\n\n  /** Creates a copy of a PathNode */\n  constructor(node: PathNode);\n  /** Creates a new (empty) PathNode for a State */\n  constructor(state: StateObject);\n  constructor(stateOrNode: any) {\n    if (stateOrNode instanceof PathNode) {\n      const node: PathNode = stateOrNode;\n      this.state = node.state;\n      this.paramSchema = node.paramSchema.slice();\n      this.paramValues = extend({}, node.paramValues);\n      this.resolvables = node.resolvables.slice();\n      this.views = node.views && node.views.slice();\n    } else {\n      const state: StateObject = stateOrNode;\n      this.state = state;\n      this.paramSchema = state.parameters({ inherit: false });\n      this.paramValues = {};\n      this.resolvables = state.resolvables.map(res => res.clone());\n    }\n  }\n\n  clone() {\n    return new PathNode(this);\n  }\n\n  /** Sets [[paramValues]] for the node, from the values of an object hash */\n  applyRawParams(params: RawParams): PathNode {\n    const getParamVal = (paramDef: Param) => [paramDef.id, paramDef.value(params[paramDef.id])];\n    this.paramValues = this.paramSchema.reduce((memo, pDef) => applyPairs(memo, getParamVal(pDef)), {});\n    return this;\n  }\n\n  /** Gets a specific [[Param]] metadata that belongs to the node */\n  parameter(name: string): Param {\n    return find(this.paramSchema, propEq('id', name));\n  }\n\n  /**\n   * @returns true if the state and parameter values for another PathNode are\n   * equal to the state and param values for this PathNode\n   */\n  equals(node: PathNode, paramsFn?: GetParamsFn): boolean {\n    const diff = this.diff(node, paramsFn);\n    return diff && diff.length === 0;\n  }\n\n  /**\n   * Finds Params with different parameter values on another PathNode.\n   *\n   * Given another node (of the same state), finds the parameter values which differ.\n   * Returns the [[Param]] (schema objects) whose parameter values differ.\n   *\n   * Given another node for a different state, returns `false`\n   *\n   * @param node The node to compare to\n   * @param paramsFn A function that returns which parameters should be compared.\n   * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n   */\n  diff(node: PathNode, paramsFn?: GetParamsFn): Param[] | false {\n    if (this.state !== node.state) return false;\n\n    const params: Param[] = paramsFn ? paramsFn(this) : this.paramSchema;\n    return Param.changed(params, this.paramValues, node.paramValues);\n  }\n}\n\n/** @hidden */\nexport type GetParamsFn = (pathNode: PathNode) => Param[];\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}