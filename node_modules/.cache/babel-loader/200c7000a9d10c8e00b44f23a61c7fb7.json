{"ast":null,"code":"/** @packageDocumentation @publicapi @module transition */\nimport { isString, isFunction, Glob, extend, removeFrom, tail, values, identity, mapObj } from '../common';\nimport { // has or is using\nTransitionHookScope } from './interface';\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\n\nexport function matchState(state, criterion, transition) {\n  var toMatch = isString(criterion) ? [criterion] : criterion;\n\n  function matchGlobs(_state) {\n    var globStrings = toMatch;\n\n    for (var i = 0; i < globStrings.length; i++) {\n      var glob = new Glob(globStrings[i]);\n\n      if (glob && glob.matches(_state.name) || !glob && globStrings[i] === _state.name) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var matchFn = isFunction(toMatch) ? toMatch : matchGlobs;\n  return !!matchFn(state, transition);\n}\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\n\nvar RegisteredHook =\n/** @class */\nfunction () {\n  function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.tranSvc = tranSvc;\n    this.eventType = eventType;\n    this.callback = callback;\n    this.matchCriteria = matchCriteria;\n    this.removeHookFromRegistry = removeHookFromRegistry;\n    this.invokeCount = 0;\n    this._deregistered = false;\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   */\n\n\n  RegisteredHook.prototype._matchingNodes = function (nodes, criterion, transition) {\n    if (criterion === true) return nodes;\n    var matching = nodes.filter(function (node) {\n      return matchState(node.state, criterion, transition);\n    });\n    return matching.length ? matching : null;\n  };\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   */\n\n\n  RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n    return mapObj(this.tranSvc._pluginapi._getPathTypes(), function () {\n      return true;\n    });\n  };\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   */\n\n\n  RegisteredHook.prototype._getMatchingNodes = function (treeChanges, transition) {\n    var _this = this;\n\n    var criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n    var paths = values(this.tranSvc._pluginapi._getPathTypes());\n    return paths.reduce(function (mn, pathtype) {\n      // STATE scope criteria matches against every node in the path.\n      // TRANSITION scope criteria matches against only the last node in the path\n      var isStateHook = pathtype.scope === TransitionHookScope.STATE;\n      var path = treeChanges[pathtype.name] || [];\n      var nodes = isStateHook ? path : [tail(path)];\n      mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name], transition);\n      return mn;\n    }, {});\n  };\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   *\n   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n\n\n  RegisteredHook.prototype.matches = function (treeChanges, transition) {\n    var matches = this._getMatchingNodes(treeChanges, transition); // Check if all the criteria matched the TreeChanges object\n\n\n    var allMatched = values(matches).every(identity);\n    return allMatched ? matches : null;\n  };\n\n  RegisteredHook.prototype.deregister = function () {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  };\n\n  return RegisteredHook;\n}();\n\nexport { RegisteredHook };\n/** @hidden Return a registration function of the requested type. */\n\nexport function makeEvent(registry, transitionService, eventType) {\n  // Create the object which holds the registered transition hooks.\n  var _registeredHooks = registry._registeredHooks = registry._registeredHooks || {};\n\n  var hooks = _registeredHooks[eventType.name] = [];\n  var removeHookFn = removeFrom(hooks); // Create hook registration function on the IHookRegistry for the event\n\n  registry[eventType.name] = hookRegistrationFn;\n\n  function hookRegistrationFn(matchObject, callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);\n    hooks.push(registeredHook);\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}","map":{"version":3,"sources":["@uirouter/core/transition/hookRegistry.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module transition */\nimport { isString, isFunction, Glob, extend, removeFrom, tail, values, identity, mapObj } from '../common';\nimport { PathNode } from '../path/pathNode';\nimport {\n  TransitionStateHookFn,\n  TransitionHookFn,\n  TransitionHookPhase, // has or is using\n  TransitionHookScope,\n  IHookRegistry,\n  PathType,\n} from './interface';\n\nimport {\n  HookRegOptions,\n  HookMatchCriteria,\n  TreeChanges,\n  HookMatchCriterion,\n  IMatchingNodes,\n  HookFn,\n} from './interface';\nimport { Transition } from './transition';\nimport { StateObject } from '../state/stateObject';\nimport { TransitionEventType } from './transitionEventType';\nimport { TransitionService } from './transitionService';\n\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nexport function matchState(state: StateObject, criterion: HookMatchCriterion, transition: Transition) {\n  const toMatch = isString(criterion) ? [criterion] : criterion;\n\n  function matchGlobs(_state: StateObject) {\n    const globStrings = <string[]>toMatch;\n    for (let i = 0; i < globStrings.length; i++) {\n      const glob = new Glob(globStrings[i]);\n\n      if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const matchFn = <any>(isFunction(toMatch) ? toMatch : matchGlobs);\n  return !!matchFn(state, transition);\n}\n\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nexport class RegisteredHook {\n  priority: number;\n  bind: any;\n  invokeCount = 0;\n  invokeLimit: number;\n  _deregistered = false;\n\n  constructor(\n    public tranSvc: TransitionService,\n    public eventType: TransitionEventType,\n    public callback: HookFn,\n    public matchCriteria: HookMatchCriteria,\n    public removeHookFromRegistry: (hook: RegisteredHook) => void,\n    options: HookRegOptions = {} as any\n  ) {\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   */\n  private _matchingNodes(nodes: PathNode[], criterion: HookMatchCriterion, transition: Transition): PathNode[] {\n    if (criterion === true) return nodes;\n    const matching = nodes.filter(node => matchState(node.state, criterion, transition));\n    return matching.length ? matching : null;\n  }\n\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   */\n  private _getDefaultMatchCriteria(): HookMatchCriteria {\n    return mapObj(this.tranSvc._pluginapi._getPathTypes(), () => true);\n  }\n\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   */\n  private _getMatchingNodes(treeChanges: TreeChanges, transition: Transition): IMatchingNodes {\n    const criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n    const paths: PathType[] = values(this.tranSvc._pluginapi._getPathTypes());\n\n    return paths.reduce(\n      (mn: IMatchingNodes, pathtype: PathType) => {\n        // STATE scope criteria matches against every node in the path.\n        // TRANSITION scope criteria matches against only the last node in the path\n        const isStateHook = pathtype.scope === TransitionHookScope.STATE;\n        const path = treeChanges[pathtype.name] || [];\n        const nodes: PathNode[] = isStateHook ? path : [tail(path)];\n\n        mn[pathtype.name] = this._matchingNodes(nodes, criteria[pathtype.name], transition);\n        return mn;\n      },\n      {} as IMatchingNodes\n    );\n  }\n\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   *\n   * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n   * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n  matches(treeChanges: TreeChanges, transition: Transition): IMatchingNodes {\n    const matches = this._getMatchingNodes(treeChanges, transition);\n\n    // Check if all the criteria matched the TreeChanges object\n    const allMatched = values(matches).every(identity);\n    return allMatched ? matches : null;\n  }\n\n  deregister() {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  }\n}\n\n/** @hidden Return a registration function of the requested type. */\nexport function makeEvent(\n  registry: IHookRegistry,\n  transitionService: TransitionService,\n  eventType: TransitionEventType\n) {\n  // Create the object which holds the registered transition hooks.\n  const _registeredHooks = (registry._registeredHooks = registry._registeredHooks || {});\n  const hooks = (_registeredHooks[eventType.name] = []);\n  const removeHookFn: (hook: RegisteredHook) => void = removeFrom(hooks);\n\n  // Create hook registration function on the IHookRegistry for the event\n  registry[eventType.name] = hookRegistrationFn;\n\n  function hookRegistrationFn(matchObject, callback, options = {}) {\n    const registeredHook = new RegisteredHook(\n      transitionService,\n      eventType,\n      callback,\n      matchObject,\n      removeHookFn,\n      options\n    );\n    hooks.push(registeredHook);\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}