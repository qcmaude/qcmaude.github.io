{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/** @packageDocumentation @publicapi @module url */\n\n\nimport { extend, forEach, isDefined, isFunction, isObject } from '../common';\nimport { UrlMatcher } from './urlMatcher';\nimport { DefType, Param } from '../params';\n/** @internalapi */\n\nvar ParamFactory =\n/** @class */\nfunction () {\n  function ParamFactory(router) {\n    this.router = router;\n  }\n\n  ParamFactory.prototype.fromConfig = function (id, type, state) {\n    return new Param(id, type, DefType.CONFIG, this.router.urlService.config, state);\n  };\n\n  ParamFactory.prototype.fromPath = function (id, type, state) {\n    return new Param(id, type, DefType.PATH, this.router.urlService.config, state);\n  };\n\n  ParamFactory.prototype.fromSearch = function (id, type, state) {\n    return new Param(id, type, DefType.SEARCH, this.router.urlService.config, state);\n  };\n\n  return ParamFactory;\n}();\n\nexport { ParamFactory };\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.\n *\n * @internalapi\n */\n\nvar UrlMatcherFactory =\n/** @class */\nfunction () {\n  // TODO: move implementations to UrlConfig (urlService.config)\n  function UrlMatcherFactory(\n  /** @hidden */\n  router) {\n    var _this = this;\n\n    this.router = router;\n    /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n\n    this.paramFactory = new ParamFactory(this.router);\n    /** @deprecated use [[UrlConfig.caseInsensitive]] */\n\n    this.caseInsensitive = function (value) {\n      return _this.router.urlService.config.caseInsensitive(value);\n    };\n    /** @deprecated use [[UrlConfig.defaultSquashPolicy]] */\n\n\n    this.defaultSquashPolicy = function (value) {\n      return _this.router.urlService.config.defaultSquashPolicy(value);\n    };\n    /** @deprecated use [[UrlConfig.strictMode]] */\n\n\n    this.strictMode = function (value) {\n      return _this.router.urlService.config.strictMode(value);\n    };\n    /** @deprecated use [[UrlConfig.type]] */\n\n\n    this.type = function (name, definition, definitionFn) {\n      return _this.router.urlService.config.type(name, definition, definitionFn) || _this;\n    };\n\n    extend(this, {\n      UrlMatcher: UrlMatcher,\n      Param: Param\n    });\n  }\n  /**\n   * Creates a [[UrlMatcher]] for the specified pattern.\n   *\n   * @param pattern  The URL pattern.\n   * @param config  The config object hash.\n   * @returns The UrlMatcher.\n   */\n\n\n  UrlMatcherFactory.prototype.compile = function (pattern, config) {\n    var urlConfig = this.router.urlService.config; // backward-compatible support for config.params -> config.state.params\n\n    var params = config && !config.state && config.params;\n    config = params ? __assign({\n      state: {\n        params: params\n      }\n    }, config) : config;\n    var globalConfig = {\n      strict: urlConfig._isStrictMode,\n      caseInsensitive: urlConfig._isCaseInsensitive\n    };\n    return new UrlMatcher(pattern, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));\n  };\n  /**\n   * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n   *\n   * @param object  The object to perform the type check against.\n   * @returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n\n\n  UrlMatcherFactory.prototype.isMatcher = function (object) {\n    // TODO: typeof?\n    if (!isObject(object)) return false;\n    var result = true;\n    forEach(UrlMatcher.prototype, function (val, name) {\n      if (isFunction(val)) result = result && isDefined(object[name]) && isFunction(object[name]);\n    });\n    return result;\n  };\n  /** @hidden */\n\n\n  UrlMatcherFactory.prototype.$get = function () {\n    var urlConfig = this.router.urlService.config;\n    urlConfig.paramTypes.enqueue = false;\n\n    urlConfig.paramTypes._flushTypeQueue();\n\n    return this;\n  };\n\n  return UrlMatcherFactory;\n}();\n\nexport { UrlMatcherFactory };","map":{"version":3,"sources":["@uirouter/core/url/urlMatcherFactory.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module url */\nimport { extend, forEach, isDefined, isFunction, isObject } from '../common';\nimport { UrlMatcher } from './urlMatcher';\nimport { DefType, Param, ParamType, ParamTypeDefinition } from '../params';\nimport { UrlMatcherCompileConfig } from './interface';\nimport { StateDeclaration } from '../state';\nimport { UIRouter } from '../router';\n\n/** @internalapi */\nexport class ParamFactory {\n  fromConfig(id: string, type: ParamType, state: StateDeclaration) {\n    return new Param(id, type, DefType.CONFIG, this.router.urlService.config, state);\n  }\n\n  fromPath(id: string, type: ParamType, state: StateDeclaration) {\n    return new Param(id, type, DefType.PATH, this.router.urlService.config, state);\n  }\n\n  fromSearch(id: string, type: ParamType, state: StateDeclaration) {\n    return new Param(id, type, DefType.SEARCH, this.router.urlService.config, state);\n  }\n\n  constructor(private router: UIRouter) {}\n}\n\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.\n *\n * @internalapi\n */\nexport class UrlMatcherFactory {\n  /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n  paramFactory = new ParamFactory(this.router);\n\n  // TODO: move implementations to UrlConfig (urlService.config)\n  constructor(/** @hidden */ private router: UIRouter) {\n    extend(this, { UrlMatcher, Param });\n  }\n\n  /**\n   * Creates a [[UrlMatcher]] for the specified pattern.\n   *\n   * @param pattern  The URL pattern.\n   * @param config  The config object hash.\n   * @returns The UrlMatcher.\n   */\n  compile(pattern: string, config?: UrlMatcherCompileConfig) {\n    const urlConfig = this.router.urlService.config;\n    // backward-compatible support for config.params -> config.state.params\n    const params = config && !config.state && (config as any).params;\n    config = params ? { state: { params }, ...config } : config;\n    const globalConfig = { strict: urlConfig._isStrictMode, caseInsensitive: urlConfig._isCaseInsensitive };\n    return new UrlMatcher(pattern, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));\n  }\n\n  /**\n   * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n   *\n   * @param object  The object to perform the type check against.\n   * @returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  isMatcher(object: any): boolean {\n    // TODO: typeof?\n    if (!isObject(object)) return false;\n    let result = true;\n\n    forEach(UrlMatcher.prototype, (val, name) => {\n      if (isFunction(val)) result = result && (isDefined(object[name]) && isFunction(object[name]));\n    });\n    return result;\n  }\n\n  /** @hidden */\n  $get() {\n    const urlConfig = this.router.urlService.config;\n    urlConfig.paramTypes.enqueue = false;\n    urlConfig.paramTypes._flushTypeQueue();\n    return this;\n  }\n\n  /** @deprecated use [[UrlConfig.caseInsensitive]] */\n  caseInsensitive = (value?: boolean) => this.router.urlService.config.caseInsensitive(value);\n\n  /** @deprecated use [[UrlConfig.defaultSquashPolicy]] */\n  defaultSquashPolicy = (value?: boolean | string) => this.router.urlService.config.defaultSquashPolicy(value);\n\n  /** @deprecated use [[UrlConfig.strictMode]] */\n  strictMode = (value?: boolean) => this.router.urlService.config.strictMode(value);\n\n  /** @deprecated use [[UrlConfig.type]] */\n  type = (name: string, definition?: ParamTypeDefinition, definitionFn?: () => ParamTypeDefinition) => {\n    return this.router.urlService.config.type(name, definition, definitionFn) || this;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}