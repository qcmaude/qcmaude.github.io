{"ast":null,"code":"/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n  var options = transition.options();\n  var $state = transition.router.stateService;\n  var $urlRouter = transition.router.urlRouter; // Dont update the url in these situations:\n  // The transition was triggered by a URL sync (options.source === 'url')\n  // The user doesn't want the url to update (options.location === false)\n  // The destination state, and all parents have no navigable url\n\n  if (options.source !== 'url' && options.location && $state.$current.navigable) {\n    var urlOptions = {\n      replace: options.location === 'replace'\n    };\n    $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n  }\n\n  $urlRouter.update(true);\n};\n\nexport var registerUpdateUrl = function (transitionService) {\n  return transitionService.onSuccess({}, updateUrl, {\n    priority: 9999\n  });\n};","map":{"version":3,"sources":["@uirouter/core/hooks/url.ts"],"names":[],"mappings":"AAOA;;;;AAIG;AACH,IAAM,SAAS,GAAqB,UAAC,UAAD,EAAuB;AACzD,MAAM,OAAO,GAAG,UAAU,CAAC,OAAX,EAAhB;AACA,MAAM,MAAM,GAAiB,UAAU,CAAC,MAAX,CAAkB,YAA/C;AACA,MAAM,UAAU,GAAc,UAAU,CAAC,MAAX,CAAkB,SAAhD,CAHyD,CAKzD;AACA;AACA;AACA;;AACA,MAAI,OAAO,CAAC,MAAR,KAAmB,KAAnB,IAA4B,OAAO,CAAC,QAApC,IAAgD,MAAM,CAAC,QAAP,CAAgB,SAApE,EAA+E;AAC7E,QAAM,UAAU,GAAG;AAAE,MAAA,OAAO,EAAE,OAAO,CAAC,QAAR,KAAqB;AAAhC,KAAnB;AACA,IAAA,UAAU,CAAC,IAAX,CAAgB,MAAM,CAAC,QAAP,CAAgB,SAAhB,CAA0B,GAA1C,EAA+C,MAAM,CAAC,MAAtD,EAA8D,UAA9D;AACD;;AAED,EAAA,UAAU,CAAC,MAAX,CAAkB,IAAlB;AACD,CAfD;;AAiBA,OAAO,IAAM,iBAAiB,GAAG,UAAC,iBAAD,EAAqC;AACpE,SAAA,iBAAiB,CAAC,SAAlB,CAA4B,EAA5B,EAAgC,SAAhC,EAA2C;AAAE,IAAA,QAAQ,EAAE;AAAZ,GAA3C,CAAA;AAA8D,CADzD","sourcesContent":["/** @packageDocumentation @internalapi @module hooks */\nimport { UrlRouter } from '../url/urlRouter';\nimport { StateService } from '../state/stateService';\nimport { Transition } from '../transition/transition';\nimport { TransitionHookFn } from '../transition/interface';\nimport { TransitionService } from '../transition/transitionService';\n\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nconst updateUrl: TransitionHookFn = (transition: Transition) => {\n  const options = transition.options();\n  const $state: StateService = transition.router.stateService;\n  const $urlRouter: UrlRouter = transition.router.urlRouter;\n\n  // Dont update the url in these situations:\n  // The transition was triggered by a URL sync (options.source === 'url')\n  // The user doesn't want the url to update (options.location === false)\n  // The destination state, and all parents have no navigable url\n  if (options.source !== 'url' && options.location && $state.$current.navigable) {\n    const urlOptions = { replace: options.location === 'replace' };\n    $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n  }\n\n  $urlRouter.update(true);\n};\n\nexport const registerUpdateUrl = (transitionService: TransitionService) =>\n  transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}