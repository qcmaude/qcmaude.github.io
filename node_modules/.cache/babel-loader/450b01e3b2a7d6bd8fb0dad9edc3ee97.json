{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/** @packageDocumentation @reactapi @module components */\n\n\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { cloneElement, createContext, createElement, isValidElement, useEffect, useMemo, useState, Component, forwardRef, useImperativeHandle, useRef } from 'react';\nimport { ResolveContext, Transition, applyPairs } from '@uirouter/core';\nimport { useParentView } from '../hooks/useParentView';\nimport { useRouter } from '../hooks/useRouter';\n/** @internalapi */\n\nvar viewIdCounter = 0;\nexport var TransitionPropCollisionError = '`transition` cannot be used as resolve token. ' + 'Please rename your resolve to avoid conflicts with the router transition.';\n/** @internalapi */\n\nexport var UIViewContext = createContext(undefined);\n/** @deprecated use [[useParentView]] or React.useContext(UIViewContext) */\n\nexport var UIViewConsumer = UIViewContext.Consumer;\n/** @hidden */\n\nfunction useResolvesWithStringTokens(resolveContext, injector) {\n  return useMemo(function () {\n    if (resolveContext && injector) {\n      var stringTokens = resolveContext.getTokens().filter(function (x) {\n        return typeof x === 'string';\n      });\n\n      if (stringTokens.indexOf('transition') !== -1) {\n        throw new Error(TransitionPropCollisionError);\n      }\n\n      return stringTokens.map(function (token) {\n        return [token, injector.get(token)];\n      }).reduce(applyPairs, {});\n    } else {\n      return {};\n    }\n  }, [resolveContext, injector]);\n}\n/* @hidden These are the props are passed to the routed component. */\n\n\nfunction useRoutedComponentProps(router, stateName, viewConfig, component, resolves, className, style, transition) {\n  var keyCounterRef = useRef(0); // Always re-mount if the viewConfig changes\n\n  var key = useMemo(function () {\n    return (++keyCounterRef.current).toString();\n  }, [viewConfig]);\n  var baseChildProps = useMemo(function () {\n    return __assign(__assign({}, resolves), {\n      // if a className prop was passed to the UIView, forward it\n      className: className,\n      // if a style prop was passed to the UIView, forward it\n      style: style,\n      // the transition\n      transition: transition,\n      // this key updates whenever the state is reloaded, causing the component to remount\n      key: key\n    });\n  }, [component, resolves, className, style, transition, key]);\n  var maybeRefProp = useUiCanExitClassComponentHook(router, stateName, component);\n  return useMemo(function () {\n    return __assign(__assign({}, baseChildProps), maybeRefProp);\n  }, [baseChildProps, maybeRefProp]);\n}\n/** @hidden */\n\n\nfunction useViewConfig() {\n  var _a = useState(),\n      viewConfig = _a[0],\n      setViewConfig = _a[1];\n\n  var viewConfigRef = useRef(viewConfig);\n  viewConfigRef.current = viewConfig;\n\n  var configUpdated = function (newConfig) {\n    if (newConfig !== viewConfigRef.current) {\n      setViewConfig(newConfig);\n    }\n  };\n\n  return {\n    viewConfig: viewConfig,\n    configUpdated: configUpdated\n  };\n}\n/** @hidden */\n\n\nfunction useReactHybridApi(ref, uiViewData, uiViewAddress) {\n  var reactHybridApi = useRef({\n    uiViewData: uiViewData,\n    uiViewAddress: uiViewAddress\n  });\n  reactHybridApi.current.uiViewData = uiViewData;\n  reactHybridApi.current.uiViewAddress = uiViewAddress;\n  useImperativeHandle(ref, function () {\n    return reactHybridApi.current;\n  });\n}\n/**\n * If a class component is being rendered, wire up its uiCanExit method\n * Return a { ref: Ref<ClassComponentInstance> } if passed a component class\n * Return an empty object {} if passed anything else\n * The returned object should be spread as props onto the child component\n * @hidden\n */\n\n\nfunction useUiCanExitClassComponentHook(router, stateName, maybeComponentClass) {\n  // Use refs and run the callback outside of any render pass\n  var componentInstanceRef = useRef();\n  var deregisterRef = useRef(function () {\n    return undefined;\n  });\n\n  function callbackRef(componentInstance) {\n    // Use refs\n    var previous = componentInstanceRef.current;\n    var deregisterPreviousTransitionHook = deregisterRef.current;\n\n    if (previous !== componentInstance) {\n      componentInstanceRef.current = componentInstance;\n      deregisterPreviousTransitionHook();\n      var uiCanExit = componentInstance === null || componentInstance === void 0 ? void 0 : componentInstance.uiCanExit;\n\n      if (uiCanExit) {\n        var boundCallback = uiCanExit.bind(componentInstance);\n        deregisterRef.current = router.transitionService.onBefore({\n          exiting: stateName\n        }, boundCallback);\n      } else {\n        deregisterRef.current = function () {\n          return undefined;\n        };\n      }\n    }\n  }\n\n  return useMemo(function () {\n    var _a;\n\n    var isComponentClass = ((_a = maybeComponentClass === null || maybeComponentClass === void 0 ? void 0 : maybeComponentClass.prototype) === null || _a === void 0 ? void 0 : _a.render) || (maybeComponentClass === null || maybeComponentClass === void 0 ? void 0 : maybeComponentClass.render);\n    return isComponentClass ? {\n      ref: callbackRef\n    } : undefined;\n  }, [maybeComponentClass]);\n}\n\nvar View = forwardRef(function View(props, forwardedRef) {\n  var _a;\n\n  var children = props.children,\n      render = props.render,\n      className = props.className,\n      style = props.style;\n  var router = useRouter();\n  var parent = useParentView();\n  var creationContext = parent.context;\n\n  var _b = useViewConfig(),\n      viewConfig = _b.viewConfig,\n      configUpdated = _b.configUpdated;\n\n  var component = useMemo(function () {\n    var _a;\n\n    return (_a = viewConfig === null || viewConfig === void 0 ? void 0 : viewConfig.viewDecl) === null || _a === void 0 ? void 0 : _a.component;\n  }, [viewConfig]);\n  var name = props.name || '$default';\n  var fqn = parent.fqn ? parent.fqn + '.' + name : name;\n  var id = useMemo(function () {\n    return ++viewIdCounter;\n  }, []); // This object contains all the metadata for this UIView\n\n  var uiViewData = useMemo(function () {\n    return {\n      $type: 'react',\n      id: id,\n      name: name,\n      fqn: fqn,\n      creationContext: creationContext,\n      configUpdated: configUpdated,\n      config: viewConfig\n    };\n  }, [id, name, fqn, parent, creationContext, viewConfig]);\n  var viewContext = (_a = viewConfig === null || viewConfig === void 0 ? void 0 : viewConfig.viewDecl) === null || _a === void 0 ? void 0 : _a.$context;\n  var stateName = viewContext === null || viewContext === void 0 ? void 0 : viewContext.name;\n  var uiViewAddress = {\n    fqn: fqn,\n    context: viewContext\n  };\n  var resolveContext = useMemo(function () {\n    return viewConfig ? new ResolveContext(viewConfig.path) : undefined;\n  }, [viewConfig]);\n  var injector = useMemo(function () {\n    return resolveContext === null || resolveContext === void 0 ? void 0 : resolveContext.injector();\n  }, [resolveContext]);\n  var transition = useMemo(function () {\n    return injector === null || injector === void 0 ? void 0 : injector.get(Transition);\n  }, [injector]);\n  var resolves = useResolvesWithStringTokens(resolveContext, injector);\n  var childProps = useRoutedComponentProps(router, stateName, viewConfig, component, resolves, className, style, transition); // temporarily expose a ref with an API on it for @uirouter/react-hybrid to use\n\n  useReactHybridApi(forwardedRef, uiViewData, uiViewAddress); // Register/deregister any time the uiViewData changes\n\n  useEffect(function () {\n    return router.viewService.registerUIView(uiViewData);\n  }, [uiViewData]);\n  var childElement = !component && isValidElement(children) ? cloneElement(children, childProps) : createElement(component || 'div', childProps); // if a render function is passed, use that. otherwise render the component normally\n\n  var ChildOrRenderFunction = typeof render !== 'undefined' && component ? render(component, childProps) : childElement;\n  return React.createElement(UIViewContext.Provider, {\n    value: uiViewAddress\n  }, ChildOrRenderFunction);\n});\nView.displayName = 'UIView';\nView.propTypes = {\n  name: PropTypes.string,\n  className: PropTypes.string,\n  style: PropTypes.object,\n  render: PropTypes.func\n}; // A wrapper class for react-hybrid to monkey patch\n\nvar UIView =\n/** @class */\nfunction (_super) {\n  __extends(UIView, _super);\n\n  function UIView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  UIView.prototype.render = function () {\n    return React.createElement(View, __assign({}, this.props));\n  };\n\n  UIView.displayName = 'UIView';\n  UIView.propTypes = View.propTypes;\n  UIView.__internalViewComponent = View;\n  return UIView;\n}(Component);\n\nexport { UIView };","map":{"version":3,"sources":["@uirouter/react/components/UIView.tsx"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @reactapi @module components */\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\nimport {\n  ComponentType,\n  ReactNode,\n  ValidationMap,\n  cloneElement,\n  createContext,\n  createElement,\n  isValidElement,\n  useEffect,\n  useMemo,\n  useState,\n  Component,\n  forwardRef,\n  useImperativeHandle,\n  useRef,\n} from 'react';\nimport {\n  ActiveUIView,\n  ResolveContext,\n  StateParams,\n  Transition,\n  TypedMap,\n  UIInjector,\n  ViewConfig,\n  ViewContext,\n  applyPairs,\n  UIRouter,\n} from '@uirouter/core';\nimport { useParentView } from '../hooks/useParentView';\nimport { useRouter } from '../hooks/useRouter';\nimport { ReactViewConfig } from '../reactViews';\n\n/** @internalapi */\nlet viewIdCounter = 0;\n\n/** @internalapi */\nexport interface UIViewAddress {\n  context: ViewContext;\n  fqn: string;\n}\n\n/**\n * Interface for [[InjectedProps.resolves]]\n *\n * This Typescript interface shows what fields are available on the `resolves` field.\n */\nexport interface UIViewResolves {\n  /**\n   * Any key/value pair defined by a state's resolve\n   *\n   * If a state defines any [[ReactStateDeclaration.resolve]]s, they will be found on this object.\n   */\n  [key: string]: any;\n  /**\n   * The `StateParams` for the `Transition` that activated the component\n   *\n   * This is an alias for:\n   * ```js\n   * let $stateParams = $transition$.params(\"to\");\n   * ```\n   */\n  $stateParams: StateParams;\n  /** The `Transition` that activated the component */\n  $transition$: Transition;\n}\n\n/**\n * Function type for [[UIViewProps.render]]\n *\n * If the `render` function prop is provided, the `UIView` will use it instead of rendering the component by itself.\n * @internalapi\n */\nexport type RenderPropCallback = (Component: ComponentType<any>, Props: any) => JSX.Element | null;\n\nexport interface UIViewInjectedProps {\n  transition?: Transition;\n  resolves?: UIViewResolves;\n  className?: string;\n  style?: Object;\n}\n\n/** Component Props for `UIView` */\nexport interface UIViewProps {\n  children?: ReactNode;\n  name?: string;\n  className?: string;\n  style?: Object;\n  render?: RenderPropCallback;\n}\n\nexport const TransitionPropCollisionError =\n  '`transition` cannot be used as resolve token. ' +\n  'Please rename your resolve to avoid conflicts with the router transition.';\n\n/** @internalapi */\nexport const UIViewContext = createContext<UIViewAddress>(undefined);\n/** @deprecated use [[useParentView]] or React.useContext(UIViewContext) */\nexport const UIViewConsumer = UIViewContext.Consumer;\n\n/** @hidden */\nfunction useResolvesWithStringTokens(resolveContext: ResolveContext, injector: UIInjector) {\n  return useMemo(() => {\n    if (resolveContext && injector) {\n      const stringTokens: string[] = resolveContext.getTokens().filter(x => typeof x === 'string');\n      if (stringTokens.indexOf('transition') !== -1) {\n        throw new Error(TransitionPropCollisionError);\n      }\n      return stringTokens.map(token => [token, injector.get(token)]).reduce(applyPairs, {});\n    } else {\n      return {};\n    }\n  }, [resolveContext, injector]);\n}\n\n/* @hidden These are the props are passed to the routed component. */\nfunction useRoutedComponentProps(\n  router: UIRouter,\n  stateName: string,\n  viewConfig: ViewConfig,\n  component: React.FunctionComponent<any> | React.ComponentClass<any> | React.ClassicComponentClass<any>,\n  resolves: TypedMap<any> | {},\n  className: string,\n  style: Object,\n  transition: any\n): UIViewInjectedProps & { key: string } {\n  const keyCounterRef = useRef(0);\n  // Always re-mount if the viewConfig changes\n  const key = useMemo(() => (++keyCounterRef.current).toString(), [viewConfig]);\n\n  const baseChildProps = useMemo(\n    () => ({\n      // spread each string resolve as a separate prop\n      ...resolves,\n      // if a className prop was passed to the UIView, forward it\n      className,\n      // if a style prop was passed to the UIView, forward it\n      style,\n      // the transition\n      transition,\n      // this key updates whenever the state is reloaded, causing the component to remount\n      key,\n    }),\n    [component, resolves, className, style, transition, key]\n  );\n\n  const maybeRefProp = useUiCanExitClassComponentHook(router, stateName, component);\n\n  return useMemo(() => ({ ...baseChildProps, ...maybeRefProp }), [baseChildProps, maybeRefProp]);\n}\n\n/** @hidden */\nfunction useViewConfig() {\n  const [viewConfig, setViewConfig] = useState<ReactViewConfig>();\n  const viewConfigRef = useRef(viewConfig);\n  viewConfigRef.current = viewConfig;\n  const configUpdated = (newConfig: ViewConfig) => {\n    if (newConfig !== viewConfigRef.current) {\n      setViewConfig(newConfig as ReactViewConfig);\n    }\n  };\n  return { viewConfig, configUpdated };\n}\n\n/** @hidden */\nfunction useReactHybridApi(ref: React.Ref<unknown>, uiViewData: ActiveUIView, uiViewAddress: UIViewAddress) {\n  const reactHybridApi = useRef({ uiViewData, uiViewAddress });\n  reactHybridApi.current.uiViewData = uiViewData;\n  reactHybridApi.current.uiViewAddress = uiViewAddress;\n  useImperativeHandle(ref, () => reactHybridApi.current);\n}\n\n/**\n * If a class component is being rendered, wire up its uiCanExit method\n * Return a { ref: Ref<ClassComponentInstance> } if passed a component class\n * Return an empty object {} if passed anything else\n * The returned object should be spread as props onto the child component\n * @hidden\n */\nfunction useUiCanExitClassComponentHook(router: UIRouter, stateName: string, maybeComponentClass: any) {\n  // Use refs and run the callback outside of any render pass\n  const componentInstanceRef = useRef<any>();\n  const deregisterRef = useRef<Function>(() => undefined);\n\n  function callbackRef(componentInstance) {\n    // Use refs\n    const previous = componentInstanceRef.current;\n    const deregisterPreviousTransitionHook = deregisterRef.current;\n\n    if (previous !== componentInstance) {\n      componentInstanceRef.current = componentInstance;\n      deregisterPreviousTransitionHook();\n\n      const uiCanExit = componentInstance?.uiCanExit;\n      if (uiCanExit) {\n        const boundCallback = uiCanExit.bind(componentInstance);\n        deregisterRef.current = router.transitionService.onBefore({ exiting: stateName }, boundCallback);\n      } else {\n        deregisterRef.current = () => undefined;\n      }\n    }\n  }\n\n  return useMemo(() => {\n    const isComponentClass = maybeComponentClass?.prototype?.render || maybeComponentClass?.render;\n    return isComponentClass ? { ref: callbackRef } : undefined;\n  }, [maybeComponentClass]);\n}\n\nconst View = forwardRef(function View(props: UIViewProps, forwardedRef) {\n  const { children, render, className, style } = props;\n\n  const router = useRouter();\n  const parent = useParentView();\n  const creationContext = parent.context;\n\n  const { viewConfig, configUpdated } = useViewConfig();\n  const component = useMemo(() => viewConfig?.viewDecl?.component, [viewConfig]);\n\n  const name = props.name || '$default';\n  const fqn = parent.fqn ? parent.fqn + '.' + name : name;\n  const id = useMemo(() => ++viewIdCounter, []);\n\n  // This object contains all the metadata for this UIView\n  const uiViewData: ActiveUIView = useMemo(() => {\n    return { $type: 'react', id, name, fqn, creationContext, configUpdated, config: viewConfig as ViewConfig };\n  }, [id, name, fqn, parent, creationContext, viewConfig]);\n  const viewContext: ViewContext = viewConfig?.viewDecl?.$context;\n  const stateName: string = viewContext?.name;\n  const uiViewAddress: UIViewAddress = { fqn, context: viewContext };\n  const resolveContext = useMemo(() => (viewConfig ? new ResolveContext(viewConfig.path) : undefined), [viewConfig]);\n  const injector = useMemo(() => resolveContext?.injector(), [resolveContext]);\n  const transition = useMemo(() => injector?.get(Transition), [injector]);\n  const resolves = useResolvesWithStringTokens(resolveContext, injector);\n\n  const childProps = useRoutedComponentProps(\n    router,\n    stateName,\n    viewConfig,\n    component,\n    resolves,\n    className,\n    style,\n    transition\n  );\n\n  // temporarily expose a ref with an API on it for @uirouter/react-hybrid to use\n  useReactHybridApi(forwardedRef, uiViewData, uiViewAddress);\n\n  // Register/deregister any time the uiViewData changes\n  useEffect(() => router.viewService.registerUIView(uiViewData), [uiViewData]);\n\n  const childElement =\n    !component && isValidElement(children)\n      ? cloneElement(children, childProps)\n      : createElement(component || 'div', childProps);\n\n  // if a render function is passed, use that. otherwise render the component normally\n  const ChildOrRenderFunction =\n    typeof render !== 'undefined' && component ? render(component, childProps) : childElement;\n  return <UIViewContext.Provider value={uiViewAddress}>{ChildOrRenderFunction}</UIViewContext.Provider>;\n});\n\nView.displayName = 'UIView';\nView.propTypes = {\n  name: PropTypes.string,\n  className: PropTypes.string,\n  style: PropTypes.object,\n  render: PropTypes.func,\n} as ValidationMap<UIViewProps>;\n\n// A wrapper class for react-hybrid to monkey patch\nexport class UIView extends Component<UIViewProps> {\n  static displayName = 'UIView';\n  static propTypes = View.propTypes;\n  static __internalViewComponent: ComponentType<UIViewProps> = View;\n  render() {\n    return <View {...this.props} />;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}