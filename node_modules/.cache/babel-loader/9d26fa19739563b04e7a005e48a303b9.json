{"ast":null,"code":"/** @packageDocumentation @publicapi @module transition */\nimport { extend, assertPredicate, unnestR, identity } from '../common/common';\nimport { isArray } from '../common/predicates';\nimport { TransitionHookPhase, TransitionHookScope } from './interface';\nimport { TransitionHook } from './transitionHook';\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\n\nvar HookBuilder =\n/** @class */\nfunction () {\n  function HookBuilder(transition) {\n    this.transition = transition;\n  }\n\n  HookBuilder.prototype.buildHooksForPhase = function (phase) {\n    var _this = this;\n\n    var $transitions = this.transition.router.transitionService;\n    return $transitions._pluginapi._getEvents(phase).map(function (type) {\n      return _this.buildHooks(type);\n    }).reduce(unnestR, []).filter(identity);\n  };\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   */\n\n\n  HookBuilder.prototype.buildHooks = function (hookType) {\n    var transition = this.transition;\n    var treeChanges = transition.treeChanges(); // Find all the matching registered hooks for a given hook type\n\n    var matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);\n    if (!matchingHooks) return [];\n    var baseHookOptions = {\n      transition: transition,\n      current: transition.options().current\n    };\n\n    var makeTransitionHooks = function (hook) {\n      // Fetch the Nodes that caused this hook to match.\n      var matches = hook.matches(treeChanges, transition); // Select the PathNode[] that will be used as TransitionHook context objects\n\n      var matchingNodes = matches[hookType.criteriaMatchPath.name]; // Return an array of HookTuples\n\n      return matchingNodes.map(function (node) {\n        var _options = extend({\n          bind: hook.bind,\n          traceData: {\n            hookType: hookType.name,\n            context: node\n          }\n        }, baseHookOptions);\n\n        var state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;\n        var transitionHook = new TransitionHook(transition, state, hook, _options);\n        return {\n          hook: hook,\n          node: node,\n          transitionHook: transitionHook\n        };\n      });\n    };\n\n    return matchingHooks.map(makeTransitionHooks).reduce(unnestR, []).sort(tupleSort(hookType.reverseSort)).map(function (tuple) {\n      return tuple.transitionHook;\n    });\n  };\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   *\n   * @returns an array of matched [[RegisteredHook]]s\n   */\n\n\n  HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges, transition) {\n    var isCreate = hookType.hookPhase === TransitionHookPhase.CREATE; // Instance and Global hook registries\n\n    var $transitions = this.transition.router.transitionService;\n    var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n    return registries.map(function (reg) {\n      return reg.getHooks(hookType.name);\n    }) // Get named hooks from registries\n    .filter(assertPredicate(isArray, \"broken event named: \" + hookType.name)) // Sanity check\n    .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n    .filter(function (hook) {\n      return hook.matches(treeChanges, transition);\n    }); // Only those satisfying matchCriteria\n  };\n\n  return HookBuilder;\n}();\n\nexport { HookBuilder };\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\n\nfunction tupleSort(reverseDepthSort) {\n  if (reverseDepthSort === void 0) {\n    reverseDepthSort = false;\n  }\n\n  return function nodeDepthThenPriority(l, r) {\n    var factor = reverseDepthSort ? -1 : 1;\n    var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n  };\n}","map":{"version":3,"sources":["@uirouter/core/transition/hookBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module transition */\nimport { extend, tail, assertPredicate, unnestR, identity } from '../common/common';\nimport { isArray } from '../common/predicates';\n\nimport {\n  TransitionOptions,\n  TransitionHookOptions,\n  IHookRegistry,\n  TreeChanges,\n  IMatchingNodes,\n  TransitionHookPhase,\n  TransitionHookScope,\n} from './interface';\n\nimport { Transition } from './transition';\nimport { TransitionHook } from './transitionHook';\nimport { StateObject } from '../state/stateObject';\nimport { PathNode } from '../path/pathNode';\nimport { TransitionService } from './transitionService';\nimport { TransitionEventType } from './transitionEventType';\nimport { RegisteredHook } from './hookRegistry';\n\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nexport class HookBuilder {\n  constructor(private transition: Transition) {}\n\n  buildHooksForPhase(phase: TransitionHookPhase): TransitionHook[] {\n    const $transitions = this.transition.router.transitionService;\n    return $transitions._pluginapi\n      ._getEvents(phase)\n      .map(type => this.buildHooks(type))\n      .reduce(unnestR, [])\n      .filter(identity);\n  }\n\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   */\n  buildHooks(hookType: TransitionEventType): TransitionHook[] {\n    const transition = this.transition;\n    const treeChanges = transition.treeChanges();\n\n    // Find all the matching registered hooks for a given hook type\n    const matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);\n    if (!matchingHooks) return [];\n\n    const baseHookOptions = <TransitionHookOptions>{\n      transition: transition,\n      current: transition.options().current,\n    };\n\n    const makeTransitionHooks = (hook: RegisteredHook) => {\n      // Fetch the Nodes that caused this hook to match.\n      const matches: IMatchingNodes = hook.matches(treeChanges, transition);\n      // Select the PathNode[] that will be used as TransitionHook context objects\n      const matchingNodes: PathNode[] = matches[hookType.criteriaMatchPath.name];\n\n      // Return an array of HookTuples\n      return matchingNodes.map(node => {\n        const _options = extend(\n          {\n            bind: hook.bind,\n            traceData: { hookType: hookType.name, context: node },\n          },\n          baseHookOptions\n        );\n\n        const state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;\n        const transitionHook = new TransitionHook(transition, state, hook, _options);\n        return <HookTuple>{ hook, node, transitionHook };\n      });\n    };\n\n    return matchingHooks\n      .map(makeTransitionHooks)\n      .reduce(unnestR, [])\n      .sort(tupleSort(hookType.reverseSort))\n      .map(tuple => tuple.transitionHook);\n  }\n\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   *\n   * @returns an array of matched [[RegisteredHook]]s\n   */\n  public getMatchingHooks(\n    hookType: TransitionEventType,\n    treeChanges: TreeChanges,\n    transition: Transition\n  ): RegisteredHook[] {\n    const isCreate = hookType.hookPhase === TransitionHookPhase.CREATE;\n\n    // Instance and Global hook registries\n    const $transitions = this.transition.router.transitionService;\n    const registries = isCreate ? [$transitions] : [this.transition, $transitions];\n\n    return registries\n      .map((reg: IHookRegistry) => reg.getHooks(hookType.name)) // Get named hooks from registries\n      .filter(assertPredicate(isArray, `broken event named: ${hookType.name}`)) // Sanity check\n      .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n      .filter(hook => hook.matches(treeChanges, transition)); // Only those satisfying matchCriteria\n  }\n}\n\ninterface HookTuple {\n  hook: RegisteredHook;\n  node: PathNode;\n  transitionHook: TransitionHook;\n}\n\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort = false) {\n  return function nodeDepthThenPriority(l: HookTuple, r: HookTuple): number {\n    const factor = reverseDepthSort ? -1 : 1;\n    const depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n    return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}