{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/** @packageDocumentation @reactapi @module components */\n\n\nimport * as React from 'react';\nimport { useState, useCallback, useContext, useMemo, cloneElement } from 'react';\nimport * as _classNames from 'classnames';\nimport { useCurrentStateAndParams, useRouter } from '../hooks';\n/** @hidden */\n\nvar classNames = _classNames;\n/** @internalapi */\n\nvar rootAddStateInfoFn = function () {\n  return function () {\n    return undefined;\n  };\n};\n\nexport var UISrefActiveContext = React.createContext(rootAddStateInfoFn);\n/**\n * A component working alongside `[[UISref]]` to add classes to its child element when one of the included `[[UISref]]`'s state is active, and removing them when it is inactive.\n *\n * The primary use-case is to simplify the special appearance of navigation menus relying on `[[<UISref>]]`, by having the \"active\" state's menu button appear different, distinguishing it from the inactive menu items.\n *\n * It will register **every** nested `[[<UISref>]]` and add the class to its child every time one of the states is active.\n *\n * ```jsx\n * <UISrefActive class=\"active-item\">\n *   <UISref to=\"homestate\"><a class=\"menu-item\">Home</a></UISref>\n * </UISrefActive>\n *\n * // rendered when state is inactive\n * <a href=\"/path/to/homestate\" class=\"menu-item\">Home</a>\n *\n * // rendered when state is active\n * <a href=\"/path/to/homestate\" class=\"menu-item active-item\">Home</a>\n * ```\n */\n\nexport function UISrefActive(_a) {\n  var children = _a.children,\n      className = _a.className,\n      classToApply = _a.class,\n      exact = _a.exact;\n  var stateService = useRouter().stateService;\n  var parentAddStateInfo = useContext(UISrefActiveContext); // keep track of states to watch and their activeClasses\n\n  var _b = useState([]),\n      uiSrefs = _b[0],\n      setUiSrefs = _b[1];\n\n  var currentState = useCurrentStateAndParams();\n  var isAnyUiSrefActive = useMemo(function () {\n    return uiSrefs.some(function (_a) {\n      var stateName = _a.stateName,\n          params = _a.params;\n      return exact ? stateService.is(stateName, params) : stateService.includes(stateName, params);\n    });\n  }, [uiSrefs, exact, stateService, currentState]);\n  var addStateInfo = useCallback(function (stateName, params) {\n    var parentDeregister = parentAddStateInfo(stateName, params);\n    var addedUiSref = {\n      stateName: stateName,\n      params: params\n    };\n    setUiSrefs(function (uiSrefs) {\n      return uiSrefs.concat(addedUiSref);\n    });\n    return function () {\n      parentDeregister();\n      setUiSrefs(function (uiSrefs) {\n        return uiSrefs.filter(function (x) {\n          return x !== addedUiSref;\n        });\n      });\n    };\n  }, [parentAddStateInfo]); // If any active class is defined, apply it the children\n\n  var childrenWithActiveClasses = isAnyUiSrefActive ? cloneElement(children, __assign(__assign({}, children.props), {\n    className: classNames(className, children.props.className, classToApply)\n  })) : children;\n  return React.createElement(UISrefActiveContext.Provider, {\n    value: addStateInfo\n  }, childrenWithActiveClasses);\n}","map":{"version":3,"sources":["@uirouter/react/components/UISrefActive.tsx"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;;;AACA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,QAAT,EAAmB,WAAnB,EAAgC,UAAhC,EAA4C,OAA5C,EAAqD,YAArD,QAAyE,OAAzE;AACA,OAAO,KAAK,WAAZ,MAA6B,YAA7B;AAEA,SAAS,wBAAT,EAAmC,SAAnC,QAAoD,UAApD;AAEA;;AACA,IAAI,UAAU,GAAG,WAAjB;AAUA;;AACA,IAAM,kBAAkB,GAAmB,YAAA;AAAM,SAAA,YAAA;AAAM,WAAA,SAAA;AAAN,GAAA;AAAe,CAAhE;;AACA,OAAO,IAAM,mBAAmB,GAAG,KAAK,CAAC,aAAN,CAAoC,kBAApC,CAA5B;AAsBP;;;;;;;;;;;;;;;;;;AAkBG;;AACH,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAA6F;MAApE,QAAA,GAAA,EAAA,CAAA,Q;MAAU,SAAA,GAAA,EAAA,CAAA,S;MAAW,YAAA,GAAA,EAAA,CAAA,K;MAAqB,KAAA,GAAA,EAAA,CAAA,K;AAC/D,MAAA,YAAA,GAAA,SAAA,GAAA,YAAA;AACR,MAAM,kBAAkB,GAAG,UAAU,CAAC,mBAAD,CAArC,CAFiG,CAIjG;;AACM,MAAA,EAAA,GAAA,QAAA,CAAA,EAAA,CAAA;AAAA,MAAC,OAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAU,UAAA,GAAA,EAAA,CAAA,CAAA,CAAV;;AACN,MAAM,YAAY,GAAG,wBAAwB,EAA7C;AAEA,MAAM,iBAAiB,GAAG,OAAO,CAAC,YAAA;AAChC,WAAO,OAAO,CAAC,IAAR,CAAa,UAAC,EAAD,EAAsB;UAAnB,SAAA,GAAA,EAAA,CAAA,S;UAAW,MAAA,GAAA,EAAA,CAAA,M;AAChC,aAAO,KAAK,GAAG,YAAY,CAAC,EAAb,CAAgB,SAAhB,EAA2B,MAA3B,CAAH,GAAwC,YAAY,CAAC,QAAb,CAAsB,SAAtB,EAAiC,MAAjC,CAApD;AACD,KAFM,CAAP;AAGD,GAJgC,EAI9B,CAAC,OAAD,EAAU,KAAV,EAAiB,YAAjB,EAA+B,YAA/B,CAJ8B,CAAjC;AAMA,MAAM,YAAY,GAAG,WAAW,CAC9B,UAAC,SAAD,EAAoB,MAApB,EAAkC;AAChC,QAAM,gBAAgB,GAAG,kBAAkB,CAAC,SAAD,EAAY,MAAZ,CAA3C;AACA,QAAM,WAAW,GAAG;AAAE,MAAA,SAAS,EAAA,SAAX;AAAa,MAAA,MAAM,EAAA;AAAnB,KAApB;AACA,IAAA,UAAU,CAAC,UAAA,OAAA,EAAO;AAAI,aAAA,OAAO,CAAC,MAAR,CAAA,WAAA,CAAA;AAA2B,KAAvC,CAAV;AACA,WAAO,YAAA;AACL,MAAA,gBAAgB;AAChB,MAAA,UAAU,CAAC,UAAA,OAAA,EAAO;AAAI,eAAA,OAAO,CAAC,MAAR,CAAe,UAAA,CAAA,EAAC;AAAI,iBAAA,CAAC,KAAD,WAAA;AAApB,SAAA,CAAA;AAAsC,OAAlD,CAAV;AACD,KAHD;AAID,GAT6B,EAU9B,CAAC,kBAAD,CAV8B,CAAhC,CAdiG,CA2BjG;;AACA,MAAM,yBAAyB,GAAG,iBAAiB,GAC/C,YAAY,CAAC,QAAD,EAAS,QAAA,CAAA,QAAA,CAAA,EAAA,EAChB,QAAQ,CAAC,KADO,CAAA,EACF;AACjB,IAAA,SAAS,EAAE,UAAU,CAAC,SAAD,EAAY,QAAQ,CAAC,KAAT,CAAe,SAA3B,EAAsC,YAAtC;AADJ,GADE,CAAT,CADmC,GAK/C,QALJ;AAOA,SAAO,KAAA,CAAA,aAAA,CAAC,mBAAmB,CAAC,QAArB,EAA6B;AAAC,IAAA,KAAK,EAAE;AAAR,GAA7B,EAAoD,yBAApD,CAAP;AACD","sourcesContent":["/** @packageDocumentation @reactapi @module components */\nimport * as React from 'react';\nimport { useState, useCallback, useContext, useMemo, cloneElement } from 'react';\nimport * as _classNames from 'classnames';\n\nimport { useCurrentStateAndParams, useRouter } from '../hooks';\n\n/** @hidden */\nlet classNames = _classNames;\n\nexport interface UISrefActiveState {\n  stateName: string;\n  params: object;\n}\n\n/** @hidden */\nexport type AddStateInfoFn = (to: string, params: { [key: string]: any }) => () => void;\n\n/** @internalapi */\nconst rootAddStateInfoFn: AddStateInfoFn = () => () => undefined;\nexport const UISrefActiveContext = React.createContext<AddStateInfoFn>(rootAddStateInfoFn);\n\nexport interface UISrefActiveProps {\n  /**\n   * The class string to apply when the state is active (i.e. `\"menu-item-active\"`)\n   */\n  class?: string;\n  /**\n   * Whether the target state of the child [[UISref]] should match exactly the state or could also be a child state.\n   * When set to `true`, if state params are supplied then they will be tested for strict equality against the current active url params, so all params must match with none missing and no extras.\n   */\n  exact?: Boolean;\n  /**\n   * The component to apply the active class to. It should be a [[UISref]] or any node with [[UISref]] descendant\n   */\n  children?: any;\n  /**\n   * Any class will be passed down to its child component\n   */\n  className?: string;\n}\n\n/**\n * A component working alongside `[[UISref]]` to add classes to its child element when one of the included `[[UISref]]`'s state is active, and removing them when it is inactive.\n *\n * The primary use-case is to simplify the special appearance of navigation menus relying on `[[<UISref>]]`, by having the \"active\" state's menu button appear different, distinguishing it from the inactive menu items.\n *\n * It will register **every** nested `[[<UISref>]]` and add the class to its child every time one of the states is active.\n *\n * ```jsx\n * <UISrefActive class=\"active-item\">\n *   <UISref to=\"homestate\"><a class=\"menu-item\">Home</a></UISref>\n * </UISrefActive>\n *\n * // rendered when state is inactive\n * <a href=\"/path/to/homestate\" class=\"menu-item\">Home</a>\n *\n * // rendered when state is active\n * <a href=\"/path/to/homestate\" class=\"menu-item active-item\">Home</a>\n * ```\n */\nexport function UISrefActive({ children, className, class: classToApply, exact }: UISrefActiveProps) {\n  const { stateService } = useRouter();\n  const parentAddStateInfo = useContext(UISrefActiveContext);\n\n  // keep track of states to watch and their activeClasses\n  const [uiSrefs, setUiSrefs] = useState<UISrefActiveState[]>([]);\n  const currentState = useCurrentStateAndParams();\n\n  const isAnyUiSrefActive = useMemo(() => {\n    return uiSrefs.some(({ stateName, params }) => {\n      return exact ? stateService.is(stateName, params) : stateService.includes(stateName, params);\n    });\n  }, [uiSrefs, exact, stateService, currentState]);\n\n  const addStateInfo = useCallback(\n    (stateName: string, params: object) => {\n      const parentDeregister = parentAddStateInfo(stateName, params);\n      const addedUiSref = { stateName, params };\n      setUiSrefs(uiSrefs => uiSrefs.concat(addedUiSref));\n      return () => {\n        parentDeregister();\n        setUiSrefs(uiSrefs => uiSrefs.filter(x => x !== addedUiSref));\n      };\n    },\n    [parentAddStateInfo]\n  );\n\n  // If any active class is defined, apply it the children\n  const childrenWithActiveClasses = isAnyUiSrefActive\n    ? cloneElement(children, {\n        ...children.props,\n        className: classNames(className, children.props.className, classToApply),\n      })\n    : children;\n\n  return <UISrefActiveContext.Provider value={addStateInfo}>{childrenWithActiveClasses}</UISrefActiveContext.Provider>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}