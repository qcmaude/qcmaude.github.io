{"ast":null,"code":"/** @packageDocumentation @publicapi @module params */\nimport { extend, filter, map } from '../common/common';\nimport { isArray, isDefined } from '../common/predicates';\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\n\nvar ParamType =\n/** @class */\nfunction () {\n  /**\n   * @param def  A configuration object which contains the custom type definition.  The object's\n   *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n   * @returns a new ParamType object\n   */\n  function ParamType(def) {\n    /** @inheritdoc */\n    this.pattern = /.*/;\n    /** @inheritdoc */\n\n    this.inherit = true;\n    extend(this, def);\n  } // consider these four methods to be \"abstract methods\" that should be overridden\n\n  /** @inheritdoc */\n\n\n  ParamType.prototype.is = function (val, key) {\n    return true;\n  };\n  /** @inheritdoc */\n\n\n  ParamType.prototype.encode = function (val, key) {\n    return val;\n  };\n  /** @inheritdoc */\n\n\n  ParamType.prototype.decode = function (val, key) {\n    return val;\n  };\n  /** @inheritdoc */\n\n\n  ParamType.prototype.equals = function (a, b) {\n    // tslint:disable-next-line:triple-equals\n    return a == b;\n  };\n\n  ParamType.prototype.$subPattern = function () {\n    var sub = this.pattern.toString();\n    return sub.substr(1, sub.length - 2);\n  };\n\n  ParamType.prototype.toString = function () {\n    return \"{ParamType:\" + this.name + \"}\";\n  };\n  /** Given an encoded string, or a decoded object, returns a decoded object */\n\n\n  ParamType.prototype.$normalize = function (val) {\n    return this.is(val) ? val : this.decode(val);\n  };\n  /**\n   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n   * e.g.:\n   * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n   * - url: \"/path?queryParam=1&queryParam=2\n   * - $stateParams.queryParam will be [1, 2]\n   * if `mode` is \"auto\", then\n   * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n   * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n   */\n\n\n  ParamType.prototype.$asArray = function (mode, isSearch) {\n    if (!mode) return this;\n    if (mode === 'auto' && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n    return new ArrayType(this, mode);\n  };\n\n  return ParamType;\n}();\n\nexport { ParamType };\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\n\nfunction ArrayType(type, mode) {\n  var _this = this; // Wrap non-array value as array\n\n\n  function arrayWrap(val) {\n    return isArray(val) ? val : isDefined(val) ? [val] : [];\n  } // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\n\n  function arrayUnwrap(val) {\n    switch (val.length) {\n      case 0:\n        return undefined;\n\n      case 1:\n        return mode === 'auto' ? val[0] : val;\n\n      default:\n        return val;\n    }\n  } // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\n\n  function arrayHandler(callback, allTruthyMode) {\n    return function handleArray(val) {\n      if (isArray(val) && val.length === 0) return val;\n      var arr = arrayWrap(val);\n      var result = map(arr, callback);\n      return allTruthyMode === true ? filter(result, function (x) {\n        return !x;\n      }).length === 0 : arrayUnwrap(result);\n    };\n  } // Wraps type (.equals) functions to operate on each value of an array\n\n\n  function arrayEqualsHandler(callback) {\n    return function handleArray(val1, val2) {\n      var left = arrayWrap(val1),\n          right = arrayWrap(val2);\n      if (left.length !== right.length) return false;\n\n      for (var i = 0; i < left.length; i++) {\n        if (!callback(left[i], right[i])) return false;\n      }\n\n      return true;\n    };\n  }\n\n  ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n    var paramTypeFn = type[name].bind(type);\n    var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n    _this[name] = wrapperFn(paramTypeFn);\n  });\n  extend(this, {\n    dynamic: type.dynamic,\n    name: type.name,\n    pattern: type.pattern,\n    inherit: type.inherit,\n    raw: type.raw,\n    is: arrayHandler(type.is.bind(type), true),\n    $arrayMode: mode\n  });\n}","map":{"version":3,"sources":["@uirouter/core/params/paramType.ts"],"names":[],"mappings":"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","sourcesContent":["/** @packageDocumentation @publicapi @module params */\nimport { extend, filter, map } from '../common/common';\nimport { isArray, isDefined } from '../common/predicates';\nimport { ParamTypeDefinition } from './interface';\n\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nexport class ParamType implements ParamTypeDefinition {\n  /** @inheritdoc */\n  pattern: RegExp = /.*/;\n  /** The name/id of the parameter type */\n  name: string;\n  /** @inheritdoc */\n  raw: boolean;\n  /** @inheritdoc */\n  dynamic: boolean;\n  /** @inheritdoc */\n  inherit = true;\n\n  /**\n   * @param def  A configuration object which contains the custom type definition.  The object's\n   *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n   * @returns a new ParamType object\n   */\n  constructor(def: ParamTypeDefinition) {\n    extend(this, def);\n  }\n\n  // consider these four methods to be \"abstract methods\" that should be overridden\n  /** @inheritdoc */\n  is(val: any, key?: string): boolean {\n    return true;\n  }\n  /** @inheritdoc */\n  encode(val: any, key?: string): string | string[] {\n    return val;\n  }\n  /** @inheritdoc */\n  decode(val: string, key?: string): any {\n    return val;\n  }\n  /** @inheritdoc */\n  equals(a: any, b: any): boolean {\n    // tslint:disable-next-line:triple-equals\n    return a == b;\n  }\n\n  $subPattern() {\n    const sub = this.pattern.toString();\n    return sub.substr(1, sub.length - 2);\n  }\n\n  toString() {\n    return `{ParamType:${this.name}}`;\n  }\n\n  /** Given an encoded string, or a decoded object, returns a decoded object */\n  $normalize(val: any) {\n    return this.is(val) ? val : this.decode(val);\n  }\n\n  /**\n   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n   * e.g.:\n   * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n   * - url: \"/path?queryParam=1&queryParam=2\n   * - $stateParams.queryParam will be [1, 2]\n   * if `mode` is \"auto\", then\n   * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n   * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n   */\n  $asArray(mode: boolean | 'auto', isSearch: boolean) {\n    if (!mode) return this;\n    if (mode === 'auto' && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n    return new (<any>ArrayType)(this, mode);\n  }\n}\n\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type: ParamType, mode: boolean | 'auto') {\n  // Wrap non-array value as array\n  function arrayWrap(val: any): any[] {\n    return isArray(val) ? val : isDefined(val) ? [val] : [];\n  }\n\n  // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n  function arrayUnwrap(val: any) {\n    switch (val.length) {\n      case 0:\n        return undefined;\n      case 1:\n        return mode === 'auto' ? val[0] : val;\n      default:\n        return val;\n    }\n  }\n\n  // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n  function arrayHandler(callback: (x: any) => any, allTruthyMode?: boolean) {\n    return function handleArray(val: any) {\n      if (isArray(val) && val.length === 0) return val;\n      const arr = arrayWrap(val);\n      const result = map(arr, callback);\n      return allTruthyMode === true ? filter(result, x => !x).length === 0 : arrayUnwrap(result);\n    };\n  }\n\n  // Wraps type (.equals) functions to operate on each value of an array\n  function arrayEqualsHandler(callback: (l: any, r: any) => boolean) {\n    return function handleArray(val1: any, val2: any) {\n      const left = arrayWrap(val1),\n        right = arrayWrap(val2);\n      if (left.length !== right.length) return false;\n      for (let i = 0; i < left.length; i++) {\n        if (!callback(left[i], right[i])) return false;\n      }\n      return true;\n    };\n  }\n\n  ['encode', 'decode', 'equals', '$normalize'].forEach(name => {\n    const paramTypeFn = type[name].bind(type);\n    const wrapperFn: Function = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n    this[name] = wrapperFn(paramTypeFn);\n  });\n\n  extend(this, {\n    dynamic: type.dynamic,\n    name: type.name,\n    pattern: type.pattern,\n    inherit: type.inherit,\n    raw: type.raw,\n    is: arrayHandler(type.is.bind(type), true),\n    $arrayMode: mode,\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}